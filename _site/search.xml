<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[不如写个small-springMvc]]></title>
      <url>/java/2019/12/23/small-springMvc%E5%AE%9E%E7%8E%B0/</url>
      <content type="text"><![CDATA[WEB开发基础知识基础知识一个Http请求到来，容器将其封装成servlet中的request对象，在request中可以获得所有的http信息，然后取出来操作。操作完成后再将其封装成servlet的response对象，应用容器将response对象解析后封装成一个http response。容器和servletTomcat=web服务器+servlet/jsp容器三大组件（servlet，filter，listener）SpringMVC和servlet的关系Tomcat服务器启动时，创建1.ServletContext，此对象一直存活至关闭服务器。当http的request过来后，tomcat将其包装成2.HttpRequest类实例（也是域对象，单次请求共享），并创建空response实例，创建web.xml中对应的servlet实例，然后调用servlet中的service(request,response)，从servletContext中可以获取xml中存储的信息，所以不同的servlet间也可以贡献context域中内容。ServletContextListener监听context，HttpSessionListener监听3.HttpSession（同一会话有效，即多次请求有效）。最后返回response，这样一次完整的请求&lt;—&gt;响应流程就结束了。第4个域对象是Page，是jsp页面内共享数据。在GenericServlet（即HttpServlet的直接父类）中，init方法将ServletConfig类对象由局部变量（Tomcat容器传给该servlet的init方法一个config）提升到成员变量，即所有继承自GenericServlet的子类servlet都自动具有config，而这个config持有对ServletContext的引用（servletContext有成员变量config，而config持有对servletCont引用）。所有域对象都持有对servletContext的引用。Filter映射器：即url-&gt;servlet的映射关系,精准匹配，前缀匹配，扩展名匹配，如果都不匹配则交给DefaultServlet处理，这个类可以用来读取静态资源。DispatcherServlet，配置成.do，只拦截.do，但是起不到连接所有servlet的作用，而且有个.do很不优雅。配置成/，会导致静态资源也被拦截，且JSP也被拦截了。配置成/，此时拦截除jsp以外的所有，（因为JSPServlet会精确匹配.jsp结尾的，因此优先匹配），此时唯一要解决的就是静态资源。SpringMVC通过对静态资源目录下进行配置的方法&lt;mvc;resources mapping=”” location=”*“&gt;以判断某些资源是静态资源，不需要dispatchServlet处理，转而交给defaultServlet。所以SpringMVC就是一个DispatcherServlet么？不是，DispathcerServlet只是MVC的入口，他包含完整的组件。如下下章节所示：SpringMVC与Spring的关系  https://blog.csdn.net/justloveyou_/article/details/74295728启动过程：Tomcat启动，生成ServletContext，因为在web.xml中配置了contextLoaderListener，因此当servletContext生成时，会被Spring监听到，然后spring初始化一个启动上下文，即ApplicationContext，其实现类是XmlWebApplication。&lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;        classpath:applicationContext.xml    &lt;/param-value&gt;&lt;/context-param&gt;如上xml所配置的，ContextLoaderListener监听到servletContext后，从web.xml找到Spring的配置目录（通过context-param），即applicaitonContext.xml。这个xml将被封装成ApplicationContext，放到servletContext中，因此servletContext不仅包含web.xml内容，还包含applicationContext.xml内容的引用。下一步开始初始化web.xml中的serlvet，一般必然存在DispathcerServlet，毕竟这个是MVC的入口servlet。而DispatcherServlet在初始化的时候，会先通过servletContext获取spring的ApplicationContext，然后再初始化自己的上下文。所以servlet间共享spring中的bean，而springMVC中的各个servlet又拥有自己独立的bean空间比如dispatherServlet的bean，就不会被其他servlet访问到。小结：tomcat启动–&gt;servletContext–被监听–&gt;Spring加载上下文–&gt;SpringMVC获取Spring上下文并为每个servlet创建上下文，尤其是dispathcerServlet（这个尤其是因为我的项目里只配置了dispatcherServlet）。  Spring容器与SpringMVC容器的联系与区别          SpringMVC因为持有spring的context，因此getBean时先从自己的上下文中获取，如果没有，则向Spring获取。而Spring不持有MVC的，因此无法获取子容器的bean。一般项目中，service、dao包中实例交给Spring创建，而controller包的实例交给MVC创建。      子容器的创建后于父容器，当Spring上下文创建完毕后，才轮到mvc的创建。      SpringMVC运行流程  HandlerMapping接口实现将请求映射到应该处理它的类或者方法。  HandlerAdapter接口实现用特定的模式处理请求，如常规servlet，更复杂的MVC工作流或者POJO bean中的方法。  ViewResolver接口允许使用不同的模板引擎，即视图解析器。  使用Apache Commons文件上传或者变现自己的MultipartResolver解析multipart请求。  使用LocaleResolver解决语言环境问题。流程小结：请求—&gt;DispatcherServlet—&gt;HandlerMapping–获得ExecutionChain（拦截器+handler）—-&gt;handlerAdapter—-&gt;返回modelAndView—&gt;ViewResolver–&gt;view—-&gt;渲染—–&gt;返回响应第一步：初始化需求  Spring的初始化：启动Tomcat时，Spring容器监听到ServletContext后，读取web.xml中context-param配置项，获取Spring的applicationContext.xml的地址，然后解析xml并完成xml中所有bean的创建。  SpringMVc的初始化：调动dispatcherServlet时，SpringMVC读取web.xml中init-param配置项，定位到其xml配置文件，解析后完成所有bean的创建。实现Spring的初始化      创建类ContextLoaderListener impelements ServletContextListener可以监听tomcat的启动，注意这一步也要在web.xml中配置listener标签，这样tomcat才能感知到有这个listener。    &lt;listener&gt;    &lt;listener-class&gt;com.sonihrmvc.framework.ContextListener.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;            此时通过listener已经能够感知tomcat何时启动，那我们就要准备初始化Spring容器了。首先在WEB-INF下建立lib包，lib包中导入我们之前的sonihr-Spring项目打包成的jar包（这一步不会的可以百度，maven项目的打包其实只要点一下就行，然后在新项目的pom里要导入原来sonihr-Spring项目的依赖），如果你的tomcat启动时提示NoClassDefFoundError异常，那大概率是你的jar包没有装好。。下图为项目当前的结构        装好jar包后，填充listener的逻辑部分,本质上就是调用classPathXmlApplicationContext（这是sonihr-spring中的，这个类用于从xml或注解中进行实例的创建），读取从web.xml的context-param中的contextConfigLocation值，即spring的配置文件的地址，然后创建实例。至此，Spring的初始化就完毕了。如果上文有不懂的，我分析一下：1.不知道web.xml是干嘛用的，不知道web.xml应该配置什么，listener标签，context-param标签不知道是啥。2.不会maven，不知道web项目要把jar包放在WEB-INF/lib下并设置为库文件。3.没看过sonihr-spring教程，不懂怎么从xml中生成实例。如果这几步不很清楚，那建议夯实基础。    public class ContextLoaderListener implements ServletContextListener {    @Override    public void contextInitialized(ServletContextEvent sce) {        ServletContext servletContext = sce.getServletContext();        String springXmlPath = servletContext.getInitParameter("contextConfigLocation");        if(springXmlPath.startsWith("classpath:")){            springXmlPath = springXmlPath.substring(10);        }        ApplicationContext applicationContext = null;        try {            applicationContext = new ClassPathXmlApplicationContext(springXmlPath);            Person person = (Person) applicationContext.getBean("person");            System.out.println(person);        } catch (Exception e) {            e.printStackTrace();        }    }}            这边做了一个substring，是因为配置的是classpath:applicationContext.xml，实际上applicationContext.xml我就是放置在resources中，即根据target文件夹，就是WEB-INF/classes下，所以可以不用写。（代码极不健壮）    &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;            做个简单测试，创建一个Person类，注解用@Service，然后private String name的参数用@Value(“”)注解，因为sonihr-spring已经实现了注解注入，因此tomcat启动时，创建ServletContext时，被ContextLoaderListener监听到，然后对Spring容器进行初始化。测试时，打印person属性，发现注入成功。      SpringMVC的初始化      创建dispatherSerlvet extends HttpServlet，并且在xml中注册。在当前版本中，我们还只拦截.do结尾了，为了防止静态资源也被拦截。注意在配置中的init-param，在servlet的生命周期中，可以重写servlet的无参init方法，在init方法中对SpringMVC进行初始化。    &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.sonihrmvc.framework.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:mvcContext.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;            我们要实现以下需求：1.tomcat的ServletContext持有Spring的springContext，springMVC同时持有spring和自己的context。2.springMVC在getBean时，如果在自己的context获取不到，则去获取spring的context中的bean。第1个需求简单，只要在ServletContext中setAttribute即可。但是第2个呢？我们需要改动sonihr-spring项目了。因为在sonihr-spring项目中，applicationContext是不存在父子容器这种说法的，因此我们需要在AbstractApplicationContext模板类中加入ApplicationContext类变量parent，这个用于指向父容器。但是创建bean和获取bean都是在beanfactory中进行的，因此beanFactory中要设置ApplcationContext变量，用于保存当前调用beanFactory的ApplicationContext实例。在getbean时，优先检查当前context中是否有该beanName，如果没有则从低向高搜索父context中是否存在。sonihr-spring的改动在tag：v1.6-solve-parentContext。     public Object getBean(String name) throws Exception {        BeanDefinition beanDefinition = beanDefinitionMap.get(name);        ApplicationContext context = this.getContext();        while (beanDefinition==null&amp;&amp;context.getParent()!=null){            ApplicationContext parent = context.getParent();            Object object = parent.getBean(name);            if(object!=null){                return object;            }else{                context = parent;            }        }        if(beanDefinition==null)            throw new IllegalArgumentException("No bean named " + name + " is defined");        Object bean = beanDefinition.getBean();        //如果bean==null说明还未存在，不是单例说明是否存在都要重新创建        if(bean==null||!beanDefinition.isSingleton()){            bean=doCreateBean(name,beanDefinition);//根据生命周期来的，先创建后进行before，init,after            bean = initializeBean(bean,name);//            beanDefinition.setBean(bean);        }        return bean;    }            在DispatcherServlet的init方法中对SpringMVC进行初始化。这边要注意，我在ClassPathXmlApplicationContext构造方法中就指定了父类，因为如果你必须在读取xml创建bean前就已经设置好parent属性。    public class DispatcherServlet extends HttpServlet {    @Override    public void init() throws ServletException {        super.init();        String mvcXmlPath = this.getInitParameter("contextConfigLocation");        if(mvcXmlPath==null||mvcXmlPath.length()==0)            return;        if(mvcXmlPath.startsWith("classpath:")){            mvcXmlPath = mvcXmlPath.substring(10);        }        ServletContext servletContext = this.getServletContext();        ApplicationContext mvcContext = null;        try {            ApplicationContext springContext = (ApplicationContext)servletContext.getAttribute("springContext");            mvcContext = new ClassPathXmlApplicationContext(springContext,mvcXmlPath);            System.out.println(springContext);            PersonService personService = (PersonService) mvcContext.getBean("personService");            System.out.println("personService=" + personService);            PersonController personController = (PersonController) mvcContext.getBean("personController");            System.out.println("personController=" + personController);        } catch (Exception e) {            e.printStackTrace();        }    }}        打印结果：            小结：目前为止，已经完成了Service包用@Service注解，并通过Spring的context创建实例，Controller包用@Controller注解，通过springmvc初始化创建实例。controller依赖service，通过@Autowired进行注入。tomcat启动后，spring和springMVC的实例全部创建完毕。  第二步：HandlerMapping需求  对于上图，当输入正确URL时，控制台可以正确打印I am eating。即，可以通过@RequestMapping的方式，解析URL，定位到eating方法并执行。  利用AOP实现拦截器链。@RequestMapping的实现      目录结构如上图所示    RequestMapping是注解，目前只有一个变量就是value。HandlerExecutionChain是HandlerMapping组件返回给dispatcherServlet的返回值，其中封装了1个RequestMappingHandler实例和1个拦截器列表（目前还未实现）。RequestMappingHandler中封装了要执行的方法method，执行方法的对象bean以及参数args。AnnotationHandlerMapping是最重要的，其中保存了一个HashMap&lt;String,RequestMappingHandler&gt; handlerRegistry，其中注册了controller包中所有被@RequestMapping解析后的url与对应方法的键值对。        首先在dispatcherServlet的init方法中进行初始化，service方法中进行doDispatcher。doDispatcher目前用于将请求的url传递给AnnotationHandlerMapping，然后返回相匹配的RequestMappingHandler和拦截器们。    private void doDispatch(HttpServletRequest request,HttpServletResponse response) throws Exception {    //Todo：    HandlerExecutionChain handlerExecutionChain =  handlerMapping.getHandler(request);    RequestMappingHandler handler = handlerExecutionChain.getHandler();       //至于如何传参，就是HandlerAdapter的事情了    handler.getMethod().invoke(handler.getBean(),null);//和AOP不冲突，内部bean如果是代理类，会调用代理后方法,}            AnnotationHandlerMapping通过遍历beanFactory中的beanDefinitionMap，获得了@RequestMapping注解内的值，从而解析出request请求url所对应的方法是谁。    @Overridepublic void init() {    AbstractBeanFactory beanFactory = mvcContext.getBeanFactory();    Map&lt;String, BeanDefinition&gt; map = beanFactory.getBeanDefinitionMap();    for(Map.Entry&lt;String, BeanDefinition&gt; entry:map.entrySet()){        String prefix = null;        String suffix = null;        Class clazz = entry.getValue().getBeanClass();//通过类名获得前缀        Object bean = entry.getValue().getBean();        Annotation annotation = clazz.getAnnotation(RequestMapping.class);        if(annotation!=null){            prefix = ((RequestMapping)annotation).value();        }else{            continue;        }        Method[] methods = clazz.getMethods();//通过方法获得后缀        for(Method method:methods){            annotation =method.getAnnotation(RequestMapping.class);            if(annotation!=null){                suffix = ((RequestMapping)annotation).value();                String url = prefix + suffix;                handlerRegistry.put(url,new RequestMappingHandler(bean,method,null));                //System.out.println("url = "+url);            }else{                continue;            }        }    }}   @Overridepublic HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {       HandlerExecutionChain handlerExecutionChain = new HandlerExecutionChain();    //System.out.println("uri = "+request.getRequestURI());    RequestMappingHandler handler = handlerRegistry.get(request.getRequestURI());    //System.out.println("handler = "+handler);    handlerExecutionChain.setHandler(handler);    return handlerExecutionChain;}      拦截器链的实现      解决一个纠结了一下午+一晚上的问题。Spring中的拦截器是基于AOP的，但是SpringMVC中HandlerInteceptor却不是基于AOP，而是基于职责链。所以AOP也可以实现拦截器，NVC的HandlerInterceptor也可实现拦截器。        HandlerInterceptor接口的实现类均为MVC的拦截器类，这个接口规定了四个方法。实际的MVC中没有getpath方法，我放在这个就不需要xml配置了，直接在方法里规定要被拦截的地址即可。    public interface HandlerInterceptor{    String[] getPath();//该方法规定被拦截的地址    //该方法在请求处理之前调用，返回true表示交给下一个拦截器，返回false表示到此为止    boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;    //视图返回之后，渲染之前被调用    void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception;    void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception;}            说一下MVC中拦截器的方法调用顺序。假设有A,B,C,D拦截器，请求过来后会调用A.pre-&gt;B.pre-&gt;C.pre-&gt;D.pre-&gt;交给适配器处理请求,返回modelAndView-&gt;D.post-&gt;C.post-&gt;B.post-&gt;A.post-&gt;渲染视图-&gt;D.after-&gt;C.after-&gt;B.after-&gt;A.after。即pre是顺序的，post和after都是逆序的。不仅如此，如果C的pre返回false，顺序是A.pre-&gt;B.pre-&gt;c.pre(false)-&gt;B.after-&gt;A.after，不会走post也不会处理请求。        我们需要在AnnotationHandlerMapping中获取所有HandlerInterceptor的实现类实例，放入list中，然后判断是否和当前请求的uri匹配，将所有匹配的拦截器加入list后，利用setter方法加入HandlerExecutionChain。        在DispathceServlet中获得的HandlerExecutionChain中拥有了针对当前uri的拦截器组和handler。在handler传递给HandlerAdapter组件之前，先调用拦截器组的pre方法，如果pre方法中有返回false，即反向调用after。    private void doDispatch(HttpServletRequest request,HttpServletResponse response) throws Exception {    HandlerExecutionChain handlerExecutionChain =  handlerMapping.getHandler(request);    List&lt;HandlerInterceptor&gt; handlerInterceptors = handlerExecutionChain.getInterceptors();    RequestMappingHandler handler = handlerExecutionChain.getHandler();    for(int i=0;i&lt;handlerInterceptors.size();i++){        HandlerInterceptor interceptor = handlerInterceptors.get(i);        if(!interceptor.preHandle(request,response,handler)){            for(int j=i-1;j&gt;=0;j--){                handlerInterceptors.get(j).afterCompletion(request,response,handler,new Exception());            }            break;        }    }    //至于如何传参，就是HandlerAdapter的事情了    handler.getMethod().invoke(handler.getBean(),null);//和AOP不冲突，内部bean如果是代理类，会调用代理后方法,}        小结：第二步后，请求已经可以正确的派发到Controller的方法上，但是方法参数之类的还未能传递，叫交给HandlerAdapter组件。  第三步：HandlerAdapterHandlerMapping和HandlerAdapter的区别  对于项目中只用到注解方式的我来说，一直心中有一个疑问：既然已经可以通过HandlerMapping映射到具体方法了，那直接反射调用方法不就完了么？为什么还要多一个HandlerAdapter组件呢？因为Spring框架是慢慢发展过来的，要保证对之前的兼容性，同时还要保证扩展性，因此HandlerMapping着重于对类的匹配（早期的handler即为类，而不是具体方法，在Spring4以后handler也可以是具体方法），HandlerAdapter着重于对具体方法的调用。  由上图看出，HandlerMapping的实现类有两个分支，一个是HandlerMethodMapping，一个是UrlHandlerMapping，前者的实现类是RequestMappingHandlerMapping，其实就是我们常用的@RequestMapping注解，使用这个注解实现requestMapping接口功能时，可以直接匹配到相关的方法。其他的，比如实现Controller接口的ControllerClassNameHandlerMapping或者xml文件中配置的sampleUrlHandlerMapping或者利用bean名称的BeanNameUrlHandlerMapping都是匹配到相关的实现类。举例来说，Controller的实现类中必须实现handleRequest方法，因此在只需要匹配到这个实现类，然后在Adapter中反射调用handleRequest方法即可。  小结：HandlerMapping将URL映射为方法或者类，然后交给HandlerAdapter进一步处理，这个处理主要是调用对应的方法，填充参数，最后返回ModelAndView给DispatcherServlet。对第二步的优化  第二步中，我们只考虑了@RequestMapping注释这一种方式，即我们的AnnotationHandlerMapping类。我们抽象出一个AbstractHandlerMapping implements HandlerMapping。这个抽象类为模板类，子类可以去重写他的registryURLAndHandler方法。因为在AnnotationHandlerMapping中，这个方法就是解析注解，新建的ControllerHandlerMapping中就是获得Controller接口实现类的bean名称和实现类实例，新建的BeanNameHandlerMapping中根据bean的名称和bean的实例注册，新建的SimpleUrlHandlerMapping中就是解析xml，从而进一步注册。  在DisptcherServlet中重构代码，在doInit方法中初始化所有HandlerMapping，这样就可以获得所有的url和handler的对应关系。要注意，AbstractHandlerMapping中的map和拦截器组list需要设计为static，以防止每次子类实例init的时候，都加入同一个map和拦截器组list中。需求  实现适配器设计模式，HandlerAdapter接口。  支持多种适配方式，比如继承Controller接口的handler，普通servlet作为handler。但是本项目着重在于@RequestMapping注解下，类型为RequestMappingHandler的handler。  实现参数传递，任意类型，包括对象。适配器设计模式的实现      设计HandlerAdapter接口，具有supports和handle两个方法。前者作用为实现职责链设计模式，在DispatcherServlet中，遍历所有的HandlerAdapter方法，如果supports返回ture，即采用当前adapter，否则交给下一个。后者作用是包装处理方法，所有adapter的处理方法都被handle包装，这样用户不需要知道内部的实现细节，dispatcherServlet只要先遍历找到supports返回true的adapter，然后执行adapter的handle方法即可。    public interface HandlerAdapter {    boolean supports(Object handler);    ModelAndView handle(HttpServletRequest request,HttpServletResponse response,Object handler) throws Exception;}      参数匹配      先处理AnnotationHandlerAdapter类的handle方法：    @Overridepublic ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {    RequestMappingHandler rmHandler = (RequestMappingHandler)handler;    Object[] args = ArgumentResolverUtil.resloveRequsetParam(request,rmHandler.getMethod());    Object obj = rmHandler.getMethod().invoke(rmHandler.getBean(),args);    return new ModelAndView(obj);}        重点全在ArgumentResolverUtil这个工具类。为什么要拆出一个工具类呢？因为众多的handle中必然都需要解析request传过来的参数，因此单独做一个工具类可以避免耦合。        因此在逻辑判断中，首先判断是否在argMap中存在相同的名字：比如方法是void speak(int age)，如果request自带一个参数为age，那么就刚好匹配。如果不同，不如方法是void baby(String name,Baby baby,int age),但是request传来的传输是name=xxx,babyName=yyy,babyAge=1,weight=10,age=33，此时发现中间那一段是baby的属性，因此babyName，babyAge，weight这三个虽然出现在了argMap中，但是却不是baby这个方法的形参名字，要通过BeanUtils将这三个参数组合成Baby的实例，然后通过cast动态转型转换成parameter需要的类型。        因此在逻辑判断中，首先判断是否在argMap中存在相同的名字：比如方法是void speak(int age)，如果request自带一个参数为age，那么就刚好匹配。如果不同，不如方法是void baby(String name,Baby baby,int age),但是request传来的传输是name=xxx,babyName=yyy,babyAge=1,weight=10,age=33，此时发现中间那一段是baby的属性，因此babyName，babyAge，weight这三个虽然出现在了argMap中，但是却不是baby这个方法的形参名字，要通过BeanUtils将这三个参数组合成Baby的实例，然后通过cast动态转型转换成parameter需要的类型。    public static Object[] resloveRequsetParam(HttpServletRequest request, Method method) throws Exception {    Map&lt;String,String[]&gt; paramMap = request.getParameterMap();    Map&lt;String,String&gt; argMap = new LinkedHashMap&lt;&gt;();    for(Map.Entry&lt;String,String[]&gt; entry:paramMap.entrySet()){        String paramName = entry.getKey();        String paramValue = "";        String[] paramValueArr = entry.getValue();        for(int i=0;i&lt;paramValueArr.length;i++){            if(i==paramValueArr.length-1)                paramValue += paramValueArr[i];            else                paramValue += paramValueArr[i] + ",";        }        argMap.put(paramName,paramValue);//处理后的request键值对    }       Parameter[] parameters = method.getParameters();    Object[] args = new Object[parameters.length];    for(int i=0;i&lt;parameters.length;i++){        Parameter parameter = parameters[i];        if(argMap.containsKey(parameter.getName())){            String value = argMap.get(parameter.getName());            Type type = parameter.getType();            if(type == String.class)                args[i] = value;            else                args[i] = ConverterFactory.getConverterMap().get(parameter.getType()).parse(value);        }else {            Type type = parameter.getType();            Object bean = ((Class) type).newInstance();            try{                BeanUtils.populate(bean,argMap);                args[i] = ((Class) type).cast(bean) ;            }catch(Exception e){                args[i] = null;            }        }    }    return args;}            还有一个疑问。我凭什么能获取到方法参数的形参名称？即步骤三中的name，baby，age。这是java1.8的新特性，但是默认是不可以的，因为会增加class文件的大小。怎么开启呢？以IDEA为例，注意红圈处        小结：本步骤实现了适配器设计模式，并且能将request请求携带的参数正确传递给相应的方法并调用。值得注意的是，返回值是ModelAndView，也是下一步我们要处理的。  第四步：ViewResolver和ViewViewResolver和View的关系  对于控制器的目标方法，无论其返回值是String，View，ModelMap或是ModelAndView，SringMVC都会在内部将其封装为一个叫做ModelAndView的对象返回。这个ModelAndView会经过视图解析器（ViewResolver）解析成为最终的视图对象。  即，你控制器目标方法返回同一个字符串，会根据视图解析器的不同，生成不同的视图对象View。  视图对象View会调用render方法对视图进行渲染，得到response结果。需求  通过Model实现对视图的传参  实现JSP，HTML的视图展示，支持转发和重定向。  实现@ResponseBody注解功能。Model的实现      为什么要有Model？为什么不干脆放到Request域中或者session域中呢？因为JSP技术汇总用到了Request等域对象，但是如果前端不是JSP技术呢？通过Model来传参，实现了不依赖于任何前端技术，如果前端是jsp，那我把model的参数交给域对象即可，如果前端是别的，那我就交给那个前端可以识别的数据。实现了解耦，这真是MVC中的一步好棋。        本项目根据需求，只用实现JSP的传参即可，因此Model最后要交给Request域。Model是LinkedHashMap&lt;String,Object&gt;类型的。用法是，对于下列控制器的目标方法：    public String list(Model model) {        //获取列表页        List&lt;Seckill&gt; list = seckillService.getSeckillList();        model.addAttribute("list", list);        //list.jsp + model = ModelAndView        return "list";// /WEB-INF/jsp/"list".jsp}        只要参数列表中有Model形参，那么默认返回值ModelAndView中的model就是这个。        因此要修改ArgumentResolverUtil工具类，增加对Model类型形参的识别。下面这段代码中值得注意的是，在Util的方法中传入的model，这是因为如果控制器目标方法参数中有Model类型的形参，那么要提前创建这个Model对象出来，这样在反射调用方法后，model中就有了值，简单来说就是通过提前new Model()作为参数，在调用方法后，model的改变可以被感知到。因为java是址传递，因此传入反射方法中的参数是拷贝了一份引用传递进去，但是拷贝的引用和原来的引用指向堆中同一块内存区域，在方法中利用引用修改被引用内存区域中的值时，方法外的引用也能感知到。因此，在反射调用控制器目标方法后，model会感知到方法内对model参数进行的改变。    @Overridepublic ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {    RequestMappingHandler rmHandler = (RequestMappingHandler)handler;    Model model = new Model();    Object[] args = ArgumentResolverUtil.resloveRequsetParam(request,rmHandler.getMethod(),model);    Object obj = rmHandler.getMethod().invoke(rmHandler.getBean(),args);    if(obj instanceof ModelAndView)        return (ModelAndView)obj;    ModelAndView mv = new ModelAndView();    if(obj instanceof String){        mv.setModel(model);        mv.setView(obj);    }    return mv;}   ArgumentResolverUtil类中：...Parameter parameter = parameters[i];//如果形参中有Model类，则创建一个参数if(parameter.getType() == Model.class){    args[i] = model;    continue;}if(argMap.containsKey(parameter.getName())){...            这一步做完后，对于任意的控制器目标方法返回值 方法名(Model model,其他参数)，只要你在方法内部用model.put(String,Object)，即可传递数据保存至model。  ViewReslover和View的实现      View接口，内部一个render方法，用于将view对象返回给浏览器。ViewResolver接口，内部一个resolveViewName方法，用于将viewName解析成View实例。分别建立实现类为InternalResouceView和InternalResourceViewResolver。        当DispatcherServlet获得ModelAndView后，通过ViewResolve将viewName转化成View实例，然后将view实例调用render方法将结果返回给浏览器。    //视图解析器解析mvView view = resolver.resolveViewName(mv.getView());//页面渲染view.render(mv.getModel(),request,response);            一个页面解析器可以解析不止一种类型的页面。正如在mvcContext.xml中配置的那样，不仅要配置视图解析器，还要配置视图解析器内视图的类型。我们这里解析的是JSP，分重定向或者转发两种情况即可。    @Overridepublic View resolveViewName(String viewName) throws Exception {    if(viewClass.equals("com.sonihrmvc.framework.view.InternalResourceView")){        if(viewName.startsWith("redirect:"))            return new InternalResourceView(viewName.substring(9),true);        else            return new InternalResourceView(prefix + viewName + suffix,false);    }    return null;}        这里其实运用的是静态工厂设计模式，会出现大量的if…else…。但是因为ResolveView中已经有了view的className，其实可以用反射实现动态工厂。通过反射创建实例，然后为path动态赋值。        重定向和转发的时候要注意路径。重定向是浏览器做的，因此配置路径时，/表示主机名：即localhost:8080/，转发是服务器做的，因此配置路径时，/表示应用名：即localhost:8080/mvc/。也很好理解，因为浏览器不知道主机有多少应用，因此默认在主机根目录，服务器知道当前在运行哪一个应用，因此默认在当前应用根目录。相对路径指的是当前路径父路径+新增路径。        在render方法中就是将model中舒服传递给request域对象，然后重定向或转发到特定的jsp。    @Overridepublic void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    for(Map.Entry&lt;String,?&gt; entry:model.entrySet()){        request.setAttribute(entry.getKey(),entry.getValue());    }    if(!this.IsRedirect)        request.getRequestDispatcher(path).forward(request,response);    else        response.sendRedirect(path);}      @ResponseBody的实现      设计一个@ResponseBody注解，不需要有任何值，只是标注即可。        在AnnotationHandlerAdapter的handle方法中，判断目标方法是否具有ResponseBody注解，如果有则直接response对象向浏览器写json。        Object转JSON字符的方式，可以通过jar包，我用的是alibaba的fastJacson包。    @Overridepublic ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        RequestMappingHandler rmHandler = (RequestMappingHandler)handler;        Model model = new Model();        Object[] args = ArgumentResolverUtil.resloveRequsetParam(request,rmHandler.getMethod(),model);        Object obj = rmHandler.getMethod().invoke(rmHandler.getBean(),args);        if(obj==null)            return null;        //@ResponseBody        Annotation annotation = rmHandler.getMethod().getAnnotation(ResponseBody.class);        if(annotation!=null){            response.getWriter().write(JSONObject.toJSONString(obj));            return null;        }        if(obj instanceof ModelAndView)            return (ModelAndView)obj;        ModelAndView mv = new ModelAndView();        if(obj instanceof String){            mv.setModel(model);            mv.setView((String) obj);        }           return mv;}        &lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.58&lt;/version&gt;&lt;/dependency&gt;        小结          git tag                  step-1.1-solve-SpringInit Spring初始化          step-1.2-solve-SpringMVCInit MVC初始化          step-2.1-solve-requestMapping RequestMapping组件的实现          step-2.2-solve-interceptor 拦截器的实现          step-3.0-solve-step2Problems 解决第二步的少许问题          step-3.1-solveHandlerAdapter HandlerAdapter组件的实现          step-4.1-solveViewResolverAndView 视图及视图解析器组件的时间          step-4.2-solveResponseBody ResponseBody注解的实现                    ]]></content>
      <categories>
        
          <category> Java </category>
        
      </categories>
      <tags>
        
          <tag> springMvc </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[不如写个small-Mybatis]]></title>
      <url>/java/2019/11/10/small-mybatis%E5%AE%9E%E7%8E%B0/</url>
      <content type="text"><![CDATA[MyBatis框架概论JDBC如何演化到MyBatis  JDBC查询分析          加载JDBC驱动      建立并获取数据库连接      创建JDBC statement对象      sql语句传入参数      执行sql语句并获得查询结果      对查询结果进行转换处理并将结果返回      释放资源，关闭resultset，statement，connection。        存在哪些问题？问题与解决思路  连接的获取和释放          由上可见，JDBC每次查询或其他数据库操作都需要频繁的开启和关闭。要知道，每次连接数据库相当于一次socket通信，因此我们可以通过数据库连接池来解决，即复用数据库连接，当调用connection.close()时，并不关闭连接，而是放回连接池中等待复用，这边和线程池是类似的。本项目采用Druid连接池，QuickStart中会提及。        SQL统一存储          连接池多种多样，可能采用DBCP，也可能用Druid，因此需要通过DataSource进行解耦，我们同一从DataSource中获取数据库连接，至于DataSource中配置的是什么连接池实现，用户不必关心。实现了ORM框架与连接池的解耦      在不同的类中进行数据库操作时，不同的类中都散落着SQL语句。我们希望sql语句和具体的java类之间进行解耦，即sql语句单独放在xml配置文件中，或者单独放在某一个java类中。这一步要求我们思考，如何从配置文件中读SQL，Dom4J在一旁摩拳擦掌        传入参数映射和动态sql          即ORM，对象关系映射。传入sql语句中的参数可以是一个对象，sql语句的返回值也可以包装成一个对象      所谓动态sql，比如select * from t_dept where name = ? and age = ?，有时候用户只想查询name = huang，age随意的，或者age=10，name随意的。那你怎么解决呢？方法1.在添加两个方法，select语句中只有name和age，但是不够优雅，如果你的表有20列，那你排列组合得多少种情况？方法2.如果只有name或只有age的话，就自动生成只有age和name的语句。怎么实现了呢？通过xml标签，等。        结果映射和结果缓存          JDBC的resultSet也太麻烦了，所以要把这里封装起来。返回的除了Boolean外，查询结果还可能是Bean，List，Map。这些值都需要两点1.返回什么类型。2.需要返回的数据结构和执行结果的映射，即ResultSet和结果的转换。      可以考虑将结果缓存以提升性能。key值是sql语句和传入参数联合，如果遇到sql和参数相同的，即返回缓存值。        解决sql语句重复问题          可以将重复的sql块独立出来，在其他sql块中引用它。        逆向工程和插件          手写sql语句还是太多了，对于单表而言是否可以自动创建sql语句。      对于sql语句生成的前后，可否用拦截器实现插件。      Mybatis功能概述  Mapper接口。mapper.xml对应一个mapper接口，&lt;mapper&gt;节点中的&lt;select&gt;等标签的id对应接口方法，标签内内容对应sql语句。Mybatis通过SqlSession.get(XXXMapper.class)，通过动态代理生成一个mapper实例，将connection和statement写sql，获取resultSet等操作织入其中，最后返回list，map，bean或者boolean。当然，其实MyBatis底层有自己已经封装了一层的select，update等方法。  数据处理层。主要用处是参数映射，动态sql生成。着重说一下参数映射，包括查询阶段将javaBean转化成JDBC类型数据和将查询结果resultset的jdbcType转化成javaBean。  架构支撑层。1.事务管理机制。2.连接池机制。3.缓存机制。  引导层。核心组件：          SqlSession，顶层API，交给用户，表示一个和数据库的会话，通过其完成增删查改操作。      Executor，MyBaits调度核心，负责SQL语句的生成和查询缓存的维护      StatementHandler，封装JDBC Statement操作，负责对JDBC statement设置参数      ParamterHandler，负责将用户传递的参数转换成JDBC Statement所需要的参数      ResultSetHandler，将JDBC返回的ResultSet结果集对象转换成list类型的集合      TypeHandler，负责java数据类型和jdbc数据类型之间的映射和转换      MappedStatement，其中维护者select|update|delete|insert节点的封装      SqlSource，根据用户传递的parameterObject动态生成SQL语句并封装到BoundSql中      BoundSql，动态生成的SQL语句以及相应参数信息      Configuration，类似于ApllicationContext，读取配置文件并保存为一个配置类      MyBatis流程概述      MyBatis流程图      下面将结合代码具体分析。  MyBatis具体代码分析      SqlSessionFactoryBuilder根据XML文件流，或者Configuration类实例build出一个SqlSessionFactory。        SqlSessionFactory.openSession()相当于从连接池中获取了一个connection,创建Executor实例，创建事务实例。    DefaultSqlSessionFactory.class  private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {    Transaction tx = null;      DefaultSqlSession var8;    try {        Environment environment = this.configuration.getEnvironment();        TransactionFactory transactionFactory = this.getTransactionFactoryFromEnvironment(environment);        tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);        Executor executor = this.configuration.newExecutor(tx, execType);        var8 = new DefaultSqlSession(this.configuration, executor, autoCommit);    } catch (Exception var12) {        this.closeTransaction(tx);        throw ExceptionFactory.wrapException("Error opening session.  Cause: " + var12, var12);    } finally {        ErrorContext.instance().reset();    }      return var8;}            此时我们只是获得一条connection，session.getMapper(XxxMapper.class)时才进行创建代理实例的过程，后面会介绍。SqlSession.getMapper实际上托付给Configuration去做。    public &lt;T&gt; T getMapper(Class&lt;T&gt; type) {    return this.configuration.getMapper(type, this);}        Configuration交给自己的成员变量mapperRegistry去做。这个成员变量是Map再封装之后的，持有configuration实例和Map&lt;Class, MapperProxyFactory&gt; knownMappers，正如xml文件中写的那样，每个mappee.xml中都有一个namespace，这个namespace就是Class&lt;?&gt;,而后者是对这个接口进行代理的工厂MapperProxyFactory实例，其中封装了被代理接口和缓存。这个knownMappers应该是初始化configuration的时候就已经处理完毕的。    MapperRegistry.class  private final Configuration config;private final Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = new HashMap();        类似于Spring中的getBean方法，MyBatis中用getMapper的方式进行创建。下面代码可以看出，先根据class类型获取代理类工厂，去工厂中newInstance。注意这里是没有Spring中的单例多例的，只要你getMapper，框架就会给你newInstance一个全新的被代理实例。    MapperRegistry.class  public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {    MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory)this.knownMappers.get(type);    if (mapperProxyFactory == null) {        throw new BindingException("Type " + type + " is not known to the MapperRegistry.");    } else {        try {            return mapperProxyFactory.newInstance(sqlSession);        } catch (Exception var5) {            throw new BindingException("Error getting mapper instance. Cause: " + var5, var5);        }    }}        newInstance()中做了什么呢？    MapperProxyFactory.class  protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) {    return Proxy.newProxyInstance(this.mapperInterface.getClassLoader(), new Class[]{this.mapperInterface}, mapperProxy);}  public T newInstance(SqlSession sqlSession) {    MapperProxy&lt;T&gt; mapperProxy = new MapperProxy(sqlSession, this.mapperInterface, this.methodCache);    return this.newInstance(mapperProxy);}        其实我们知道，Proxy.newProxyInstance()需要三个参数，类加载器，被代理接口和InvocationHnadler，什么？不知道？快去补习基础。其中InvocationHandler掌管着invoke方法，正是这个方法中实现了对被代理实例的代码增强（或者叫做代理代码）。那我们就要着重看这个InvocationHandler里面到底有什么，特别是他的invoke方法。    MapperProxy.class  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {    ...省略...    MapperMethod mapperMethod = this.cachedMapperMethod(method);    return mapperMethod.execute(this.sqlSession, args);}        invoke方法中，重点是调用了mapperMethod.execute()。这个mapperMethod就是:被代理接口A，A中有方法a()，代理类实例((A)proxyA).a()中的这个a，就是method,而mapperMethod就是method被包装了一层。换而言之，(session.getMapper(XxxMapper)).interfaceMethod()时，都在走mapperMethod.execute()这个方法。        下面我们来看mapperMethod.execute这个方法。    MapperMethod.class  public Object execute(SqlSession sqlSession, Object[] args) {    Object result;    Object param;    switch(this.command.getType()) {    ...省略...    case SELECT:    ...省略...    param = this.method.convertArgsToSqlCommandParam(args);    result = sqlSession.selectOne(this.command.getName(), param);    ...省略...    }    ...省略...}        这个方法做了两件事，1.对参数用参数解析器转化为JDBCType的参数，这边不是重点。2.执行sqlSession.selectOne()，当然我删去了一些代码，为讲清楚，只讲selectOne()即可，其他都是大同小异的。又回到最初的起点，呆呆地望着镜子前。 sqlSession又见面了，发现了么？sqlSession先是把getMapper交给configuration做，然后自己还能执行类似selecOne，update之类的命令，这是因为sqlSession是暴露给用户的接口，如果用户要用传统方式，就可以直接调用selectOne之类的方法，比如Employee employee = session.selectOne(“mybatisDemo.dao.EmployeeMapper.getEmpById”,1);如果用户想用mapper.xml和mapper接口的方法，就getMapper获得代理实例然后调用接口方法即可。所以本质上，所有跟JDBC打交道的还是sqlsession的select、update等方法    现在还都是表面功夫，直到sqlSession.selectOne才开始真正的辉煌旅程。小结一下，目前我们看到的MyBatis组件包括SqlSessionFactoryBuilder、SqlSessionFactory、SqlSession。还未看到的有，Executor，ParameterHandler，StatementHandler，ResultSetHandler。这几个部件都会在之后出现。        下面来分析session.selectOne()。selectOne内部调用的还是selectList，因此直接看SqlSession的实现类DefaultSqlSession中的方法。可以发现，Executor组件终于出现了，而这个组件才是真正执行query()方法的组件。SqlSession真的是领导，getMapper交给config做，select等脏活累活又交给Executor完成。Executor.query的入参有什么？被代理方法参数parameter，ms用于动态sql的。    DefaultSqlSession.class  public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) {    List var5;    ...省略...    MappedStatement ms = this.configuration.getMappedStatement(statement);    var5 = this.executor.query(ms, this.wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);    ...省略...    return var5;}        下面去看query方法,在Executor的一个抽象实现类，其实也就是模板类BaseExecutor中。    BaseExecutor.class  public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, resultsetHandler resultsetHandler) throws SQLException {    BoundSql boundSql = ms.getBoundSql(parameter);    CacheKey key = this.createCacheKey(ms, parameter, rowBounds, boundSql);    return this.query(ms, parameter, rowBounds, resultsetHandler, key, boundSql);}        BoundSql就是动态sql，key是将sql语句，入参组合起来作为缓存参数，即：如果sql语句相同且参数一样，那可以认为两个sql语句会返回同样的结果（缓存未失效的情况下）。query方法中进一步调用doQuery方法，这个方法在BaseExecutor中只给出抽象方法，交给子类去继承实现。这个子类就是SimpleExecutor。    SimpleExecutor.class  public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, resultsetHandler resultsetHandler, BoundSql boundSql) throws SQLException {    Statement stmt = null;      List var9;    try {        Configuration configuration = ms.getConfiguration();        StatementHandler handler = configuration.newStatementHandler(this.wrapper, ms, parameter, rowBounds, resultsetHandler, boundSql);        stmt = this.prepareStatement(handler, ms.getStatementLog());        var9 = handler.query(stmt, resultsetHandler);    } finally {        this.closeStatement(stmt);    }      return var9;}        这里出现了StatementHandler这个组件，先别急着点进newStatementHandler()方法，先看一下StatementHandler接口，发现这个接口有ParameterHandler getParameterHandler();方法和 List query(Statement var1, resultsetHandler var2)。这时候，ParmeterHandler和resultsetHandler两大组件也出现了。所以这三个组件的关系是，StatementHandler中需要通过ParamterHandler处理参数，然后将结果通过resultsetHandler处理成要求的JavaBean、Map、List后输出。    小结一下：SqlSession将查询等任务交给Executor接口实现类完成，Executor内有StatementHandler，StatementHandler内有ParameterHandler和resultsetHandler，分别进行参数处理和结果处理。        还没讲newStatementHandler()这个方法呢，为什么要现在讲？    Configuration.class  public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) {    ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);    parameterHandler = (ParameterHandler)this.interceptorChain.pluginAll(parameterHandler);    return parameterHandler;}  public ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler, resultsetHandler resultsetHandler, BoundSql boundSql) {    ResultSetHandler resultSetHandler = new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultsetHandler, boundSql, rowBounds);    ResultSetHandler resultSetHandler = (ResultSetHandler)this.interceptorChain.pluginAll(resultSetHandler);    return resultSetHandler;}  public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, resultsetHandler resultsetHandler, BoundSql boundSql) {    StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultsetHandler, boundSql);    StatementHandler statementHandler = (StatementHandler)this.interceptorChain.pluginAll(statementHandler);    return statementHandler;}        值得注意的是interceptorChain，拦截器链，这里的拦截器链通过pluginAll对几个Handler进行织入。织入的是什么代码呢？是你写的拦截器代码。回忆一下MyBatis写拦截器代码的时候要指定哪些呢？1.要指定针对Exector，ParameterHandler，StatementHandler，或者resultsetHandler进行拦截2.要指定针对什么方法拦截。针对拦截器这一部分的原理，建议阅读          https://www.jianshu.com/p/b82d0a95b2f3        @Intercepts({@Signature(type= Executor.class, method = "update", args = {MappedStatement.class,Object.class})})public class ExamplePlugin implements Interceptor {    public Object intercept(Invocation invocation) throws Throwable {        return invocation.proceed();    }    public Object plugin(Object target) {        return Plugin.wrap(target, this);    }    public void setProperties(Properties properties) {    }}        这边拦截器和前面Mapper接口都是用到了动态代理。前面Mapper接口是通过动态代理技术代理Mapper接口，实现了即使我们不用谢Mapper接口实现类仍然可以调用Mapper接口内方法，因为MyBatis帮我们内部实现了一个代理类实例。这边的拦截器说的是，对于3个Handler和1个Exector接口，他们的所有接口方法都可以被拦截。所以这里拦截器所拦截的只能是这4个接口的实现类。这个拦截器主要的思路就是，被代理的实例叫target，然后把这个实例代理后，返回一个代理类实例叫proxyTarget，然后把这个proxyTarget再赋值给target，然后target再被其他代理，结果就是代理类代理代理类代理代理类。。。。层层包裹。当你调用最外层代理类实例时会从外向内一层一层执行前增强代码，然后再从内向外一层一层执行后增强代码。  快速实现一个MyBatis核心功能      DepartmentMapper.xml和DepartmentMapper接口均已完成，是如何完成departmentMapper.getDeptById(1)之后就直接获得Department对象的呢？主要是以下的核心代码：    @Testpublic void testDynamicProxy(){    Object proxy = Proxy.newProxyInstance(CoreFunction.class.getClassLoader(),            new Class[]{DepartmentMapper.class}, new InvocationHandler() {                @Override                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {                    String sql = "select id,dept_name departmentName from t_dept where id = " + args[0];                    Connection connection = DBUtil.getConnection();                    Statement statement = connection.createStatement();                    ResultSet resultSet = statement.executeQuery(sql);                    while(resultSet.next()){                        int id = resultSet.getInt(1);                        String departmentName = resultSet.getString("departmentName");                        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();                        map.put("id",id);                        map.put("departmentName",departmentName);                        Department department = new Department();                        BeanUtils.populate(department,map);                        return department;                    }                    return null;                }            });    Department department = ((DepartmentMapper)proxy).getDeptById(1);    System.out.println(department);}        核心思路就是这样：用一个动态代理来代理这个接口，然后在invoke中获得数据库连接，调用statement，封装参数，执行sql后将resultSet封装成一个javaBean返回。    除了核心代码，还有什么问题要解决？1.sql语句要从xml中获取。2.装配参数要进行转化，从javaBean转化成JDBCType。3.采用连接池，并且可以配置数据源。4.resultSet封装成javaBean。5.用拦截器实现插件。6.缓存功能。7.实现多表查询。8.如何和Spring相结合。  针对以上提出解决方案。          Dom4j技术获取。      BeanUtils实现Bean向Map的转换，即可获得对象对应属性与属性值之间关系。在xml中比如：select * from t_employee where id = #{id}#{xxx}中xxx即为map的key，获取值后填充。如果是#{}，则采用PreparedStatement填充占位符？，如果是${}用Statement,以字符串拼接形式完成sql。      采用工厂模式可以切换内置的Druid或DBCP数据源，如果用户想自己配置其他的，可以通过setter注入的方式向DefaultSessionFactory中注入数据源。      可以通过ResultSetMetaData获取列名，列名和JavaBean的参数名相对应。      利用动态代理，对4大组件进代理，在InvocationHandler的invoke方法中调用Interceptor实现类，Interceptor实现类中有intercept(Invocation)方法，invocation.proceed调用被代理实例方法，intercept中其他代码为代理代码。      这边可以用grauva实现，或者自己手写一个LRU，然后用定时任务队列实现超时失效。      目前没考虑好。      整体写完后重构。      getMapper流程getMapper主要流程  框架目录结构  batisDemo包和resource文件夹中xml文件是用于测试框架的，具体框架的实现通过com.sonihr.batis包实现。          具体来说，quickStart包中存放了一些和框架无关的代码，主要是我用于测试一些基础功能的，比如JDBC，连接池，动态代理。      session中包括SqlSessionFactory、SqlSession组件，defaults包中是这两个接口的默认实现类。      binding中就牵扯到动态代理了。            getMapper流程。和之前分析的Mybatis的流程类似，通过SqlSessionFactorybuilder的build方法获取SqlSessionFactory，并且在这里做configuration的初始化工作，因为目前还没有读取xml文件，因此字符串直接写在configuration的构造函数中。SqlSessionFactory的openSession方法获取sqlSession。SqlSession表示一个会话，其中组合了Conncetion和Configuration，逻辑也很简单，一个回话必然占据一个连接。这个会话又是直接暴露给用户的，因此必须有Configuration参数，通过传递这个参数来分配给其他组件干活。SqlSession.getMapper实际上是交给configuration去做，之前说了configuration是sqlsession的一个成员变量。configuration又交给其成员变量MapperRegistry，这个类目前的功能是调用MapperProxyFactory工厂类创建一个代理类实例。    getMapperTest.class   @Testpublic void getMapper() throws Exception {    SqlSession sqlSession = new SqlSessionFactoryBuilder().build().openSession();    DepartmentMapper departmentMapper = sqlSession.getMapper(DepartmentMapper.class);    Department department = departmentMapper.getDeptById(1);    System.out.println(department);}            getMapper讲到这里，就要去说明，怎么创建的代理的实例。    MapperProxyFactory.class   private T newInstance(MapperProxy&lt;T&gt; mapperProxy) {    return (T) Proxy.newProxyInstance(configuration.getMapperInterface().getClassLoader(), new Class[]{this.configuration.getMapperInterface()}, mapperProxy);}        由此看见，mapperProxy必然是一个InvocationHandler的实现类。如果实现了InvocationHandler接口，那必然要重写invoke方法。    @Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {    PreparedStatement ps = sqlSession.getConnection().prepareStatement(sql);    ps.setInt(1, (Integer) args[0]);    ResultSet rs = ps.executeQuery();    ResultSetMetaData rsmd = rs.getMetaData();    Object resBean = resultClazz.newInstance();    Field[] fields = resultClazz.getDeclaredFields();    Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();    while (rs.next()){        for(int i=0;i&lt;rsmd.getColumnCount();i++){            System.out.println(i);            String name = rsmd.getColumnLabel(i+1);            for(Field field:fields){                if(field.getName().equals(name)){                    Object object = rs.getObject(i+1);                    map.put(name,object);                    break;                }            }        }    }    BeanUtils.populate(resBean,map);    return resBean;}        这段代码其实就是来自quickStart包的CoreFunction中的testNameSpaceAndSql方法。在这个invoke方法中，我们预设了sql语句要填充的只有1个问号，且为int类型。并且预设了数据库字段名一定和javaBean的成员变量同名。  可配置的数据源      看一下Spring中是如何配置的    &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;    &lt;!-- 注入数据库连接池 --&gt;    &lt;property name="dataSource" ref="dataSource"/&gt;        在Factory中注入了一个DataSource，又因为是面向接口编程，因此datasource在Spring中配置为什么，就是什么。        如果没有Spring，我们可以通过set方法进行手动注入。这里我采用静态工厂的形式，支持DBCP与Druid两个数据源。在datasource包中，有一个DataSourceFactory接口，该接口规定了getDataSource方法。DBCPDataSourceFactory和DruidDataSourceFactory都实现了getDatasource方法，并返回相应类型的datasource。为了让configuration中的datasource与具体的datasourceFactory解耦，因此用DefaultDataSourceFactory来生产DBCP和Druid。    public class DefaultDataSourceFactory implements DataSourceFactory {    public DataSource getDataSource(String name) {        DataSource dataSource = null;        if(name.equals("org.apache.commons.dbcp2.BasicDataSource"))            dataSource = new DBCPDataSourceFactory().getDataSource();        else            dataSource = new DruidDataSourceFactory().getDataSource();        return dataSource;    }       @Override    public DataSource getDataSource() {        return this.getDataSource("com.alibaba.druid.pool.DruidDataSource");    }}            那用户怎么任意配置数据源呢？在DefaultSqlSession中暴露出database的set方法，用户可以选择创建数据源然后通过set方法注入。  四大组件四大组件的关系  Executor中有StatementHandler实例，StatementHandler中有ParameterHandler和resultsetHandler实例。  四大组件的初始化，都是在Configuration中进行。  四大组件在初始化的时候，都会经过拦截器代理。Executor  getMapper中的核心是MapperProxy，这是InvocationHandler的实现类，因此需要实现invoke方法，在此方法中调用mapperMethod.execute方法，MapperMethod是对method的封装，在MyBatis中需要根据执行的sql语句类型和sql返回值来调用不同的方法，因为本文中目前仅仅针对单条查询，因此这边MapperMethod只是简单地封装了method而已。execute方法调用sqlSession方法的selectOne方法进行查询，而这个方法交给Executor接口的实例去具体的查询，接口方法叫做query()。  query()方法中用doQuery方法，这个方法中需要从configuration中获得StatementHandler的实现类，先通过preparedStatement方法（注意这个是方法）完成参数转换（这个方法中调用parameterize方法，这个方法就是利用StatementHandler组件中的ParameterHandler完成的）。  参数转换完毕后，statementHandler.query传入resultsetHandler和statement，进行JDBC层面的查询，并通过resultHanler返回封装后的结果。StatementHandler      这个组件在Configuration中初始化，在Executor中被调用。Executor实现类中利用configuration.newStatementHandler创建一个statementHandler。先通过parameterHandler进行参数匹配，然后通过query进行查询。查询的结果通过resultsetHandler进行封装。    public class SimpleExecutor extends BaseExecutor{    @Override    public &lt;E&gt; List&lt;E&gt; doQuery(Connection connection,Configuration conf, Object[] args, ResultSetHandler resultSetHandler) throws Exception {        /**        * 1. 在Configuration中创建StatementHandler实例handler，StatementHandler中有ParameterHandler和ResultHandler组件实例        * 2. Executor实现类调用preparedStatement方法，这个方法中的prepare方法返回Statement或者PreparedStatement        * 3. statementHandler调用parameterize方法，调用parameterHandler组件实例处理参数        * */        StatementHandler handler = conf.newStatementHandler(args);        Statement statement = preparedStatement(connection,handler);        return handler.query(statement, resultSetHandler);    }       private Statement preparedStatement(Connection connection,StatementHandler handler) throws SQLException {        Statement statement = handler.prepare(connection);        handler.parameterize(statement);//对参数进行封装        return statement;    }}            如注释中所示，首先创建一个StatementHandler，然后preparedStatement方法中做了两件事，1是返回statement，但是这个statement既可能是Statement也可能是PreparedStatement，要根据sql语句的类型判断。2.对参数进行封装，如果是preparedStatement就要用setObject(i,obj)的方式注入参数，如果是Statement类型，通过字符串拼接的方式实现。3.最后调用statementHandler的query方法进行查询，这个query方法中有参数resultsetHandler，说明我们会在这个方法中利用resultHandler对结果进行封装。        这个接口有一个抽象模板类叫做BaseStatementHandler，他的两个实现类分别是PreparedStatementHandler和SimpleStatementHandler。这里用到了委托设计模式，通过RoutingStatementHandler中方法判断是statement还是ps，然后根据判断结果，委托给不同的实现类去做。    private boolean judgeStatementType(){    if(configuration.getSql().contains("$"))        return false;//statement    return true;//preparedStatement}            SimpleStatementHandler（SSH）和PreparedStatementHandler（PSH）是有区别的，本质区别就在一个是statement，一个是ps。在这些接口方法中，PSH的parameterize需要setObject，根据变量出现位置来赋值，但是SSH只需要将原来的${id}等标签用字符串替换即可。query方法中，SSH是statement.executeQuery(sql),但是PSH中是ps.executeQuery(),因为SQL已经预编译进去了。prepare方法中，SSH直接从Connection中createStatement，PSH还要将sql处理一下，吧#{id}这样的字符串替换为？。    public interface StatementHandler {    void parameterize(Statement statement) throws SQLException;    &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultSetHandler resultSetHandler) throws Exception;    ParameterHandler getParameterHandler();    Statement prepare(Connection connection) throws SQLException;}      ParameterHandler  先写了一个工具类ParametersUtil，用于将类似#{id},${name}的标签解析成Map，key为变量名，value为出现的位置编号，以便于以后的拓展，目前为了方便，我还是按照顺序进行赋值的，而不是根据名称。如果日后方法中传入参数是对象，那么就可以用BeanUtil将对象转换成map，然后将map和此处的map进行对应，找出变量名所对应的位置，然后用setObject放过去。ResultsetHandler      这边基本就是CoreFunction中的代码，首先获得ResultSet，然后将结果集封装成map，通过beanUtil将map转化为bean。    @Datapublic class DefaultResultHandler implements ResultSetHandler{       private Configuration configuration;       public DefaultResultHandler(Configuration configuration) {        this.configuration = configuration;    }       @Override    public &lt;E&gt; List&lt;E&gt; handleResultSets(Statement statement) throws Exception {        List&lt;E&gt; list = new ArrayList&lt;E&gt;();        ResultSet rs = null;        if(statement instanceof PreparedStatement){            PreparedStatement ps = (PreparedStatement)statement;            rs = ps.executeQuery();            System.out.println("preparedStatement");        }        else{            String sql = this.getConfiguration().getSql();            rs = statement.executeQuery(sql);            System.out.println("statement");        }        ResultSetMetaData rsmd = rs.getMetaData();        Class resultClazz = configuration.getResultClass();        Object resBean = resultClazz.newInstance();        Field[] fields = resultClazz.getDeclaredFields();        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();        while (rs.next()){            for(int i=0;i&lt;rsmd.getColumnCount();i++){                String name = rsmd.getColumnLabel(i+1);                for(Field field:fields){                    if(field.getName().equals(name)){                        Object object = rs.getObject(i+1);                        map.put(name,object);                        break;                    }                }            }            try {                BeanUtils.populate(resBean,map);            } catch (IllegalAccessException e) {                e.printStackTrace();            }            list.add((E)resBean);        }        return list;    }}      停更通知  目前实现功能：1.基于Mapper接口和动态代理 2.仅支持单条查询，具有基本ORM能力 3.数据源可配置 4.支持${}与#{}两种配置模式，防止sql注入 5.实现SqlSession、Executor、StatementHandler、ParameterHandler、ResultSetHandler等Mybatis组件。  我想做的还有1.可变SQL 2.支持多表ORM。3.支持拦截器 4，支持缓存]]></content>
      <categories>
        
          <category> Java </category>
        
      </categories>
      <tags>
        
          <tag> Mybatis </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[完善small-Spring中几个不足之处]]></title>
      <url>/java/2019/10/29/tiny-spring%E7%9A%84%E4%B8%8D%E8%B6%B3/</url>
      <content type="text"><![CDATA[不足一：未实现构造器注入      实现功能：      &lt;bean id="carByConstructor" class="com.sonihr.Car"&gt;      &lt;constructor-arg value="constructor"/&gt;      &lt;constructor-arg ref="address2"/&gt;  &lt;/bean&gt;          @Test  public void testConstructor() throws Exception {      ApplicationContext applicationContext = new ClassPathXmlApplicationContext("tinyioc.xml");      Driveable car = (Driveable) applicationContext.getBean("carByConstructor");      System.out.println(car);  }  //输出：Car{name='constructor', address=Address{local='beijingByConstructor', car=null}}              本demo暂时未实现对构造器类型的判断，只是简单按照构造器参数个数来匹配，当然想判断也很简单，都是逻辑代码而已。      构造器注入无法解决循环依赖的问题，A构造器ref b，B构造器 ref a，当A构造器ref b的时候，转而去构造b，但是b的构造器要用到a，a因为还未构造成功，因此b构造失败。Spring官方推荐使用构造器注入方法，因为这样可以避免循环依赖，会抛出异常提示，保证了注入对象不为空，保证客户端调用时返回的是已经构造完毕的对象（因为构造器注入时，依赖对象建议用final修饰，final的内存语义保证构造函数构造完毕后外界才能访问变量）            解决方案：                  核心类：ConstructorArgument类，ValueHolder类，后者是前者的内部类，封装了value，type和name，前者内部有一个List成员变量。两者关系类似PropertyValue和PropertyValues,每一个实例的name都对应着一个beanDefinition，每个beanDefinition中都有一个ConstructorArgument，每个ConstructorArgument中都有一个list&lt;valueHolder&gt;                    读取XML，根据constructor-arg子标签获取ref/value,type,name值放入beanDefinition.getConstrustorArgument.valueholder中。此时要注意，如果是ref，就要考虑如下内容：          private void processConstructorArgument(Element element,BeanDefinition beanDefinition){      NodeList constructorNodes = element.getElementsByTagName("constructor-arg");      for(int i=0;i&lt;constructorNodes.getLength();i++){          Node node = constructorNodes.item(i);          if(node instanceof Element){              Element constructorElement = (Element)node;              String name = constructorElement.getAttribute("name");              String type = constructorElement.getAttribute("type");              String value = constructorElement.getAttribute("value");              if(value!=null&amp;&amp;value.length()&gt;0){//有value标签                  beanDefinition.getConstructorArgument().addArgumentValue(new ConstructorArgument.ValueHolder(value,type,name));              }else{                  String ref = constructorElement.getAttribute("ref");                  if(ref==null||ref.length()==0){                      throw new IllegalArgumentException("Configuration problem: &lt;constructor-arg&gt; element for property '"                              + name + "' must specify a ref or value");                  }                  BeanReference beanReference = new BeanReference(ref);                  beanDefinition.getConstructorArgument().addArgumentValue(new ConstructorArgument.ValueHolder(beanReference,type,name));              }          }      }  }                          getBean会触发创建-&gt;doCreateBean-&gt;createBeanInstance，此时根据是否配置constructor-arg判断是调用有参构造还是无参构造，通过反射构建实例。                  ref对象name是否在三级缓存但是不在一级缓存？回顾一下，三级缓存的作用是存放所有还未进行before和after操作的实例，一级缓存是存放所有已经完全构建完毕的实例。如果在三级不在一级，说明ref的对象还没有被完全构建完毕，这在构造器注入中会造成循环依赖，无法解决，因此需要抛出异常进行提示。                    ref如果不在三级缓存，说明ref的实例还未创建，用getbean进行创建即可。在ref的实例创建的过程中，如果未发生循环依赖则创建成功，如果发生循环依赖则抛出异常（就是上一点说到的）                    ref如果即在三级缓存，又在一级缓存，说明ref的实例已经创建，用getbean获取即可。          //增加构造函数版本1.0，只判断参数数量相同  private Object createBeanInstance(BeanDefinition beanDefinition) throws Exception {      if(beanDefinition.getConstructorArgument().isEmpty()){//如果没有constructor-arg标签，则调用无参构造函数          return beanDefinition.getBeanClass().newInstance();      }else{          List&lt;ConstructorArgument.ValueHolder&gt; valueHolders = beanDefinition.getConstructorArgument().getArgumentValues();          Class clazz = Class.forName(beanDefinition.getBeanClassName());//获取变量类的class对象          Constructor[] cons = clazz.getConstructors();//获取所有构造器          for(Constructor constructor:cons){              if(constructor.getParameterCount()==valueHolders.size()){//这里只匹配了参数数量相同的                  Object[] params = new Object[valueHolders.size()];                  for(int i=0;i&lt;params.length;i++){                      params[i] = valueHolders.get(i).getValue();                      if(params[i] instanceof BeanReference){                          BeanReference ref = (BeanReference)params[i];                          String refName = ref.getName();                          if(thirdCache.containsKey(refName)&amp;&amp;!firstCache.containsKey(refName)){                              throw new IllegalAccessException("构造函数循环依赖"+refName);                          }else{                              params[i] = getBean(refName);                          }                      }                  }                  return constructor.newInstance(params);              }          }      }      return null;  }                    不足二：基本类型只能传递String类型参数      实现功能：不仅可以完成基本类型+Spring的赋值，还可以通过实现Converter接口的方式，自由配置String类型转任意类型。      @Test  public void testConvert() throws Exception {      ApplicationContext applicationContext = new ClassPathXmlApplicationContext("tinyioc.xml");      Driveable car = (Driveable) applicationContext.getBean("carByConvert");      System.out.println(car);  }      //结果：Car{name='notOnlySpring', price=1000, address=null}          &lt;bean id="anything" class="com.sonihr.Anything"&gt;      &lt;property name="point" value="22;99"&gt;&lt;/property&gt;  &lt;/bean&gt;  &lt;bean id="pointConverter" class="com.sonihr.beans.converter.PointConverter"&gt;&lt;/bean&gt;      @Test  public void testConvert2() throws Exception {      ApplicationContext applicationContext = new ClassPathXmlApplicationContext("tinyioc.xml");      Anything anything = (Anything) applicationContext.getBean("anything");      System.out.println(anything);  }  //结果：Anything{point=Point{x=22, y=99}}            实现思路：接口为Converter，工厂类为ConverterFactory。接口中规定了getType方法，用于获得该接口是string与什么type之间的转换关系。还规定了string与type之间的转换方法，print和parse。      public interface Converter&lt;T&gt; {      Type getType();      String print(T fieldValue);      T parse(String clientValue) throws Exception;  }        给出一个实现类：      public class PointConverter implements Converter&lt;Point&gt; {      private Type type;          public PointConverter() {          this.type = Point.class;      }          public Type getType() {          return type;      }              @Override      public String print(Point fieldValue) {          return fieldValue.getX()+";"+fieldValue.getY();      }          @Override      public Point parse(String clientValue) throws Exception {          String[] xy = clientValue.split(";");          Point point = new Point();          point.setX(Integer.valueOf(xy[0]));          point.setY(Integer.valueOf(xy[1]));          return point;      }  }        工厂类中封装了一个Map，用于保存type和相对应的converter。        在applyPropertyValues方法中，如果是非ref，则说明获取到的是string类型，应该进行转换。如果字段类型是String就不用转换，否则 先用CoverterFactory获取到ConverterMap，然后根据字段的type获取转换器。      else{      Field field = field = bean.getClass().getDeclaredField(propertyValue.getName());//获得name对应的字段      if(field.getType().toString().equals("class java.lang.String"))          convertedValue = value;      else          convertedValue = this.converterFactory.getConverterMap().get(field.getType()).parse((String)value);  }            在AbstractAoolicationContext中，因为Converter实现类都不需要进行AOP，所以要在BeanPostProcessor之前被创建，即在refresh中，在registerBeanPostProcessor之前，先registerConverter，通过beanFactory。getBeansForType获取到所有实现Concerter的实例，并创建好,然后把对应的类型和转换器加入到map中。      protected void registerBeanPostProcessors(AbstractBeanFactory beanFactory) throws Exception {      //返回的实例都是已经创建完毕的，参数都已经赋值完毕了      List beanPostProcessors = beanFactory.getBeansForType(BeanPostProcessor.class);      for (Object beanPostProcessor : beanPostProcessors) {          beanFactory.addBeanPostProcessor((BeanPostProcessor) beanPostProcessor);      }  }      不足三：未实现完整的生命周期  总结一下bean的生命周期，构造函数实例化bean——&gt;setter-&gt;BPP.before-&gt;InitializingBean.afterPropertiesSet方法-&gt;init-method-&gt;BBP.after-&gt;disposableBean.destory-&gt;destroy-Method.      init-method和destory-method，在xml中指定其所对应的方法，在我的demo中，就没有写xml了，而是所有想要实现init-method和destory-method的，都必须叫这两个名字。afterPropertiesSet方法和destroy方法需要分别继承InitializingBean接口和disposableBean方法。          实现方法                  init_method和destroy_method放在try块中，如果反射时报错noSuchMethod，这说明该类没有这个方法，那么就catch，否则就反射运行。一定是无参的。                    编写两个接口，InitalizingBean和Disposable接口。在ApplyPeopertyValues方法后，如果bean instanceof InitializingBean，则调用其afterpropertiesSet方法。在close方法中，一样的，instanceof Disposable就destroy。          public void close(){      Map&lt;String,Object&gt; thirdCache = beanFactory.getThirdCache();      Map&lt;String,Object&gt; firstCache = beanFactory.getFirstCache();      for(Map.Entry&lt;String,BeanDefinition&gt; entry:beanFactory.getBeanDefinitionMap().entrySet()){          String beanName = entry.getKey();          Object invokeBeanName = entry.getValue().getBean();          Object realClassInvokeBean = thirdCache.get(beanName);          if(realClassInvokeBean instanceof DisposableBean){              ((DisposableBean) realClassInvokeBean).destroy();          }          try{              Method method =  realClassInvokeBean.getClass().getMethod("destroy_method",null);              method.invoke(realClassInvokeBean,null);          }catch (Exception e){              }  }                             实现效果                    不足四：只实现了单例模式@Testpublic void testPrototype() throws Exception {    ApplicationContext applicationContext = new ClassPathXmlApplicationContext("prototype.xml");    for(int i=0;i&lt;3;i++){        System.out.println(applicationContext.getBean("carPrototype").hashCode());    }    for(int i=0;i&lt;3;i++)        System.out.println(applicationContext.getBean("carSingleton").hashCode());}  解决方案：读xml的时候，读取scope属性下内容，如果是singleton或者没有这个属性，就说明是单例，否则就是prototype，然后将这个属性赋值给对应的beanDefinition，isSingleton属性用来判断该beanDefinition是否为单例。如果是prototype，只需要改动创建语句，将getbean方法中的判断语句改为：if(bean==null||!beanDefinition.isSingleton())。如果不是单例，那每次都要创建，不管缓存中有没有，每次缓存中都保存一个最新的，不过保存不保存也没啥区别，反正都是返回最新的。prototype其实就是每次都走一遍getBean的创建流程而已。值得注意的是，如果单例内注入多例，单例里保存的永远是那个第一次创建时指向的多例。不足五：未实现注解和auto-scan注解  写个编译器或JVM看的信息，如果想处理这个信息，就需要自己写处理器，对于编译器编译期的注解(source和class)，继承AbstractProcessor类实现方法即可，用于自动生成代码等，相当于java——&gt;class转化时可以根据注解来进行一定的操作。对于运行期的注解(runtime)，即写给JVM看的，需要通过反射解析，然后程序员可以根据获得的注解信息进行相关操作。  元注解，即可以对注解进行注解的注解，理解成最基础的注解。          @Retention，给定了被注解注解的保留范围，source编译时进行操作，不会写入class文件，class类加载阶段丢弃，会写入class，runtime保存到运行期，可以反射获取。source和class的区别是，source强调单个java的编译期间，因此编译完成后可以丢弃。但是B.java编译时，需要依赖A.class,并且B想到看A的注解，此时就要用class（这个过程是定制开发编译过程的开发人员做的，即规定先编译B.java再编译A.java，但是编译完成后还没有运行）。保留情况：.java（source）-&gt;.class字节码（class）-&gt;内存中字节码（runtime）      @target，指定注解可以放在那些元素上，元素包括注解，构造器，成员变量，局部变量，方法等。      @Inherited，默认情况下父类注解不会被自类继承，但是如果注解了inherited则注解会默认继承。但是注解本身是无法继承的，即A注解无法派生出ASon注解。这里@Inherited的意思是被修饰的类的注解，可以继承给子类，注意区别      @Documented，被注解的注解会出现javadoc产生的文档中的内容，比如你定义的@A method(){}，如果没有加@Documented注解，则文档中只会出现method()      @Repeatable，被注解的注解可以在一个程序元素上重复出现，表达即是又是的含义            如何自定义一个注解，内部参数长得很像接口方法，“返回值”其实是设定值类型，类型可以使基本类型，String，class，枚举，注释，上述类型的数组。注意，不得为包装类或其他类实例。class类型指的是Clss&lt;?&gt;类型。      public @interface MyAnnotation{      int getId();      String getName();      String[] getTeacherNames();  }      实现注解      在spring中，对同一个bean混用注解和xml会出现错误，因此我们的需求是：对单一bean只能采用注解或者xml二选一的方式，实现@Autowired根据id而不是类型进行注入，类似@resource，如果没有指定id则默认与变量同名。（P.S.其实我就是想实现@resource）        实现目标：1.在xml中配置bean，但是bean的依赖不需要写ref，而是通过@Autowired进行自动注入。2.xml中写上&lt;component-scan base-package=”com.sonihr”\/\&gt;即可对相应的包进行自动的实例化和注入，并且此时如果xml中有其他配置的实例，可以实现注解和xml实例均创建成功。        实现目标1的解决思路                  这个思路很简单，首先设计@Autowired注解。id参数表示被注解的字段ref实例的id，比如a ref b，那@Autowird的id就是b。如果没有指定id，那么默认是被修饰的字段变量名。          @Retention(RetentionPolicy.RUNTIME)  @Target({ElementType.METHOD,ElementType.FIELD})  public @interface Autowired {      String getId() default "";  }                            然后通过xml已经可以实例化出没有ref依赖的实例了，在doCreateBean方法中，在applyPropertyValues方法后，即设置完变量的字段值后，调用injectAnnotation方法，进行注解注入。在这个方法中，判断类中所有字段是否有Autowired注解，如果有就获取autowird的值和对应的字段变量名，将其设置。因为设置的一定是ref的，即@Autowired注入的必然是依赖实例，因此通过getBean方法直接生成即可，不需要像之前还要用BeanReference类型包装。为什么要放入secondCache中呢？因为如果在注解中产生循环依赖，a ref b, b ref a，此时b中存储的对象a可能是不完整的（因为AOP的存在，a可能最终变成一个代理类实例）。因此通过secondCache保存所有有可能注入了不完美实例的实例。          protected void injectAnnotation(Object bean,BeanDefinition beanDefinition) throws Exception{      Field[] fields = bean.getClass().getDeclaredFields();      for(Field field:fields){          Autowired autowired = field.getAnnotation(Autowired.class);          if(autowired==null)              continue;          String refName = autowired.getId();          if(refName.equals("")){              refName = field.getName();          }          secondCache.put(refName,bean);          field.setAccessible(true);          field.set(bean,getBean(refName));      }  }                          实现目标2的解决思路：xml中配置&lt;component-scan base-package=”com.sonihr”/&gt;，然后通过XmlBeanDefinitionReader可以读取到该标签的包名packageName。核心是，如果遍历这个包，然后找到对应的注解并进行处理呢？          AnnotationParser类，这个类的作用是读取packageName包下（com.sonihr的路径是com/sonihr/）的所有.class文件，然后去掉.class前面的字符就是类名。这个过程是递归的，直到当钱file的子files中没有目录为止。然后将获得的set classNames（用set就是为了去重）反射获得类对象，然后就可以开心的操作其中的field了。      有两种注释，第一种是类似@Component，@Service的注解，表示该类需要被创建实例。第二种是@Value，代表该类字段值，类似于xml中property name=xxx value=xxx中的value。节省版面，可以看我项目中的代码，挺简单的。      获取到要创建的类，其名称，还有value值，就可以放入一个map&lt;String name,BeanDefinition beanDefinition&gt;中了，当所有的注解查找完成后，再交给beanFactory的registry即可，后面的创建过程倒是和xml中完全一样。本来嘛，一个是xml读取配置，一个是注解读取配置。      ]]></content>
      <categories>
        
          <category> Java </category>
        
      </categories>
      <tags>
        
          <tag> Spring </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[不如写个small-Spring]]></title>
      <url>/java/2019/10/20/small-spring%E5%AE%9E%E7%8E%B0/</url>
      <content type="text"><![CDATA[IOC  https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247484247&amp;idx=1&amp;sn=e228e29e344559e469ac3ecfa9715217&amp;chksm=ebd74256dca0cb40059f3f627fc9450f916c1e1b39ba741842d91774f5bb7f518063e5acf5a0#rd为什么要有IOC？  https://www.zhihu.com/question/23277575  什么是依赖？  依赖，可以粗暴地理解为import，如果代码中import了某个类，那这段代码就依赖了这个类。面向接口编程时，逻辑都是接口逻辑（例如接口IA，有方法doX，doY，接口逻辑例如是main中实例化了IA后，顺序执行了doX和doY），但具体实例化的对象是IA接口的实现（例如类CA实现了IA，重写了方法doX，doY）。如果不用工厂，直接new，那么main文件里面就必须import了CA，也就是main“依赖”了CA这个实现。而面向接口编程中，main应该跟CA解耦（就是不直接依赖CA，不会看到import CA）。工厂方法就是解决这种import CA的解决途径之一，简单工厂为例，原本main里面的IA a = new CA()，就变成了IA a = AFactory.getA(“CA”)，并且getA的具体实现中，可以通过如果是字符串“CA”就new CA()返回了。这样子的话，main里面就不用import CA了（但是要import AFactory），也即是不“依赖”CA，与CA解耦了。依赖注入，就是把上面的工厂，获取CA对象的方式，变成反射（也还是根据字符串来生成对象，不过就不用简单工厂if-else那么粗暴了，多一个if又要改一遍工厂的实现，多累啊），根据配置来生成对象。不用import某个实际类，但是也把依赖（逻辑过程实际执行还是CA来做的）给注入（放到main中）了。（上述的main指代任意一个逻辑执行过程，不一定是main函数）      依赖注入，把底层类作为参数传入上层类，实现上层类对下层类的控制。A类中：@Autowird B b;那不论B类怎么改变，都不需要改变A类中的代码。比如构造函数创建A(B b),还有Setter创建。反转A类中不应该B b=new b()，而是应该从外界注入。                  从哪个外界注入呢？Spring设计的是IOC容器，相当于是框架本身管理注入过程。相当于A需要B b的时候，框架就getBean（“b”）给A类。                    如果A需要b，B需要a，怎么注入？控制反转，交给IOC容器去解决。tiny-spring的实现思路：先根据xml获得全部bean标签内容，然后在getBean的时候再lazy-init。这样A需要b时，会先创建A，当遇到b时转而去创建b，最后在创建出完成的A。整个类似于一个递归（dfs）的过程。                  IOC,控制反转，通过配置文件/注解自动对对象进行初始化                  控制反转解决了对象层级嵌套的问题，在创建一个对象时可以自动创建依赖对象并注入，Spring的IOC容器实现了从xml或注解中进行自动初始化。                    控制反转容器因为是自上而下创建实例的，因此不需要知道其依赖类的创建方法，屏蔽了内部的细节,从外部看像一个工厂。                IOC部分要实现什么功能？  读取XML文件，标签为beans和property  property内标签可为value或ref，即支持依赖注入  封装成ApplicationContext创建所有的bean，并且解决循环依赖  TODO：注解版和Java配置版第0步：下载项目  https://github.com/code4craft/tiny-spring  请用git clone下载，这样才能够通过git checkout step-1-container-register-and-get一步一步的查看不同版本。第1步：最基本的容器  最基本的容器是指BeanFactory和BeanDefinition。前者有一个ConcurrentHashMap&lt;String，BeanDefinition&gt;，因为实现xml中字符串id对对象实例的映射。BeanDefinition包装了Bean。第2步：将bean创建放入工厂  Spring中Bean实例的生成是由容器控制的，而不是由用户，因此Bean对象的创建要放在BeanFactory中。为了仿照Spring，因此抽象出FactoryBean接口，AbstractBeanFactory模板类。模板类中最重要的是protected doCreateBean()。  在注册的时候通过反射调用doCreateBean方法创建对象，并放入BeanDefinition包装类中。doCreateBean相当于是个动态工厂，根据string类型的全类名反射出一个Object对象。public void registerBeanDefinition(String name,BeanDefinition beanDefinition){    Object bean =  doCreateBean(beanDefinition);    beanDefinition.setBean(bean);    beanDefinitionMap.put(name,beanDefinition);}  到这一步就实现了BeanFactory的实现类可以通过全类名创建一个对象。public class BeanFactoryTest {    @Test    public void test(){        BeanFactory beanFactory = new AutowireCapableBeanFactory();        BeanDefinition beanDefinition = new BeanDefinition();//创建一个包装类        beanDefinition.setBeanClassName("beans.Car");//通过反射创建，要求必须有无参构造函数        beanFactory.registerBeanDefinition("audi",beanDefinition);//注册到hashmap中，注册之前先调用doCreateObject方法创建对象，实现了在Facoty中创建对象        System.out.println((Car)beanFactory.getBean("audi"));    }}  在看上述代码，我们要传给factory什么？1.全类名，即beans.Car。2.实例化后的实例名称，即audi。这两项显然我们都能在配置的xml中获取，这在第四步中完成。其次，我们目前创建出的对象还是一个依靠无参构造函数创建的，因此内部成员变量均为null，所以下一步是对成员变量进行赋值。第3步：为Bean注入属性  这一步有两个类，PropertyValues和PropertyValue。PV类相当于是C++中的Pair&lt;String fieldName,Object Value&gt;类，保存字段和字段对应的值。PVS中保存了一个对象中所有字段和值的对应关系，即保存了一个List。每个BeanDefinition中都有一个PVS,因此每个BeanDefinition在创建完空Bean后可以遍历PVS，通过反射实现Setter。protected void applyPropertyValues(Object bean,BeanDefinition mbd) throws NoSuchFieldException, IllegalAccessException {   for(PropertyValue propertyValue:mbd.getPropertyValues().getPropertyValues()){       Field declaredField = bean.getClass().getDeclaredField(propertyValue.getName());       declaredField.setAccessible(true);       declaredField.set(bean,propertyValue.getValue());   }}第4步：读取xml配置来初始化bean  解决获取IO流的问题？URL类定位xml文件，url.openConnect().connect()即可定位并打开文件，利用getInputStream获得文件输入流。  通过XMLBeanDefinitionReader类和DocumentBuilder对xml进行解析。先根据bean定位到所有的bean，根据类名和实例名构建一个空实例，然后每一个bean中定位property，利用PVS类和PV类实现对bean属性的赋值  官方结构第5步：为bean注入bean  核心解决三个问题1.ref怎么实现？2.怎么解决xml中顺序问题？2.怎么避免循环依赖？      怎么实现ref？                  这个问题好解决。判断xml中是ref还是value，如果是value（本项目目前value如果是基本类型，只允许是String）则直接用PV（PropertyValue）封装，如果是ref，就用BeanReference{name,bean}封装一下然后再用PV封装。        private void processProperty(Element ele, BeanDefinition beanDefinition) {    NodeList propertyNode = ele.getElementsByTagName("property");    for (int i = 0; i &lt; propertyNode.getLength(); i++) {        Node node = propertyNode.item(i);        if (node instanceof Element) {            Element propertyEle = (Element) node;            String name = propertyEle.getAttribute("name");            String value = propertyEle.getAttribute("value");            if (value != null &amp;&amp; value.length() &gt; 0) {                beanDefinition.getPropertyValues().addPropertyValue(new PropertyValue(name, value));            } else {                String ref = propertyEle.getAttribute("ref");                if (ref == null || ref.length() == 0) {                    throw new IllegalArgumentException("Configuration problem: &lt;property&gt; element for property '"                            + name + "' must specify a ref or value");                }                BeanReference beanReference = new BeanReference(ref);                beanDefinition.getPropertyValues().addPropertyValue(new PropertyValue(name, beanReference));            }        }    }}                            在调用applyPropertyValues()方法——通过反射装填实例的成员变量时，如果该变量是BeanReference，则该变量有可能需要创建一下。        protected void applyPropertyValues(Object bean, BeanDefinition mbd) throws Exception {    for (PropertyValue propertyValue : mbd.getPropertyValues().getPropertyValues()) {        Field declaredField = bean.getClass().getDeclaredField(propertyValue.getName());        declaredField.setAccessible(true);        Object value = propertyValue.getValue();        if (value instanceof BeanReference) {            BeanReference beanReference = (BeanReference) value;            value = getBean(beanReference.getName());        }        declaredField.set(bean, value);    }}                            注意上述代码中的value=getBean(beanReference.getName())。实例的创建过程有可能就在此刻完成。这里需要明确的是下图：                读取xml后，所有的类信息都在XmlBeanDefinitionReader实例中，但是XmlBDFR中的beanDefinition们并没有创建实例，即空有类信息（className，PropertyValues），但是bean为null。此时，如果遇到A实例a的b字段ref C实例c，但是此刻C实例c还未初始化，在装配A实例a的b字段的时候，就会用getBean创建c。（为什么能创建c呢？因为在创建工厂后，紧接着的操作就是把xmlBDFR中的所有beanDefinition写入工厂的ConcurrentHashMap中，即工厂也有了全部的信息，因此可以创建c。）        BeanFactory beanFactory = new AutowireCapableBeanFactory();for(Map.Entry&lt;String,BeanDefinition&gt; beanDefinitionEntry:xmlBeanDefinitionReader.getRegistry().entrySet()){    beanFactory.registerBeanDefinition(beanDefinitionEntry.getKey(),beanDefinitionEntry.getValue());}((AutowireCapableBeanFactory) beanFactory).preInstantiateSingletons();                          通过getBean时创建实例的这种lazy-init方式，实现了不依靠xml中顺序。这样再创建实例的时候如果实例的依赖还没有创建，就先创建依赖。        所谓循环依赖是类似以下的情况    &lt;bean name="outputService" class="com.sonihr.beans.OutputService"&gt;    &lt;property name="helloWorldService" ref="helloWorldService"&gt;&lt;/property&gt;&lt;/bean&gt;   &lt;bean name="helloWorldService" class="com.sonihr.beans.HelloWorldServiceImpl"&gt;    &lt;property name="text" value="Hello World!"&gt;&lt;/property&gt;    &lt;property name="outputService" ref="outputService"&gt;&lt;/property&gt;&lt;/bean&gt;        在doCreateBean中，创建完空的bean(空的bean表示空构造函数构造出的bean)后，就放入beanDefinition中，这样a ref b，b ref a时，a ref b因此b先创建并指向a，此时的a还不是完全体，但是引用已经连上了，然后创建好了b。然后b ref a的时候，a已经创建完毕。  第6步：ApplicationContext登场      这一步就是用ApplicationContext包装之前的代码    public void refresh() throws Exception {    XmlBeanDefinitionReader xmlBeanDefinitionReader = new XmlBeanDefinitionReader(new ResourceLoader());    xmlBeanDefinitionReader.loadBeanDefinitions(configLocation);    for (Map.Entry&lt;String, BeanDefinition&gt; beanDefinitionEntry : xmlBeanDefinitionReader.getRegistry().entrySet()) {        beanFactory.registerBeanDefinition(beanDefinitionEntry.getKey(), beanDefinitionEntry.getValue());    }}            这样只要如下调用即可     ApplicationContext applicationContext = new ClassPathXmlApplicationContext("tinyioc.xml");((ClassPathXmlApplicationContext) applicationContext).refresh();System.out.println(applicationContext.getBean("car2"));      AOP  https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247483954&amp;idx=1&amp;sn=b34e385ed716edf6f58998ec329f9867&amp;chksm=ebd74333dca0ca257a77c02ab458300ef982adff3cf37eb6d8d2f985f11df5cc07ef17f659d4#rd理解动态代理设计模式      静态代理模式        通过构造函数注入的方式，将被代理类B的实例b注入Proxy中，然后Proxy实现A接口a方法时，在调用b.a()之前之后				都可以写自己的代理逻辑代码。        动态代理模式        将接口A的字节码文件+一个构造器，这个构造器继承自Proxy，就构成了代理类的基本字节码。Prxoy构造器中必然依赖InvocationHandler实例，这个InovocationHandler实例要重写invoke方法以实现1.Proxy中所有A接口方法全部使用handler.invoke。2.hanler.invoke()调用被代理实例的a(),并且可以在其中写代理逻辑。3.Proxy的a方法调用的invoke，则内部就代理a方法。        分解操作：    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {    //指定被代理类实例    Car target = new Car();    //指定类加载器和接口    Class carClazz = Proxy.getProxyClass(target.getClass().getClassLoader(),Drivebale.class);    //创建构造函数    Constructor constructor = carClazz.getConstructor(InvocationHandler.class);    //反射创建代理类实例    Drivebale car = (Drivebale) constructor.newInstance(new InvocationHandler() {        @Override        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {            System.out.println("前");            method.invoke(target,args);            System.out.println("后");            return null;        }    });    car.running();}        一句话版本：    public static void main(String[] args) {    Car target = new Car();    Drivebale car =  (Drivebale) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() {        @Override        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {            System.out.println("这就是JDK动态代理的正确用法");            method.invoke(target,args);            System.out.println("结束");            return null;        }    });    car.running();}            静态代理和动态代理的区别            本质区别，静态代理是在运行期之前就编译好的class文件，动态代理是运行期中生成的class文件。        代理模式和装饰模式的区别          相同点都是返回一个功能更丰富的类。      代理模式强调与被代理类无关的功能，比如被代理类是核心业务逻辑代码，代理模式增加日志等辅助功能。包装模式强调对被包装类进行功能性的加强。      代理模式控制对方法的访问，可以不让访问者知道被代理的对象，Thread（Runnable target），MyBatis的Mapper。装饰着模式为方法添加额外的行为，一般通过构造函数注入，IO流。            代理模式的应用                  静态代理：Thread implements Runnable，Thread(Runnable target)，thread.run{target.run}。我们只用关心Runnable的业务逻辑，而不用关系线程创建，销毁等具体的事情。                    动态代理：MyBatis中的Mapper。                    https://blog.csdn.net/xiaokang123456kao/article/details/76228684           ```java SqlSession session = sqlSessionFactory.openSession();   //获取mapper接口的代理对象   UserMapper userMapper = session.getMapper(UserMapper.class);   //调用代理对象方法   User user = userMapper.findUserById(27);  ​       ```        比如UserMapper这个接口，如果要用静态代理，就必须手动写一个实现该接口的代理类，如果你有很多个接口，就要写很多个代理类，工作量很大。但是采用动态代理后，XXXMapperProxy通过反射实现XxxMapper接口内方法并创建构造函数，创建后在invoke中实现逻辑。  理解AOP  https://blog.csdn.net/javazejian/article/details/56267036      为什么要有AOP？                  在面向对象编程的这些年，我们遇到了一些问题。                      参数检查，日志，异常处理，事务开始和提交，这些都是重复代码，怎么解决呢？面向切面编程，将这些功能抽取出来，然后定义point cut（切入点），在point cut上进功能的weaving织入，从而形成一个aspect切面。        专属名词                  join point：Spring中每个方法都可以是join point                    point cut：我们想要切入的那些join point                    advice：通知，即代理逻辑代码                    aspect：point cut+advice等于一个切面                    weaving:切面应用到目标函数的过程                    Spring AOP与Aspect  https://zhuanlan.zhihu.com/p/24565766      Spring aop和Aspect不是一个东西        Aspect是一套独立的面向切面编程的实现方案，通过编译器实现静态织入.            Spring AOP基于动态代理设计模式的动态织入，基础技术为jdk动态代理和CGLIB技术，前者基于反射技术且只应用于接口，后者基于继承了用于类。        Spring AOP使用了Aspect的部分内容(主要是实现XML配置解析和类似 Aspectj 注解方式的时候，借用了 aspectjweaver.jar 中定义的一些annotation 和 class)，但是并没有使用其编译器和织入器，可以认为是Aspect风格的，但是实现完全不同。        AOP Alliance 是AOP的接口标准，定义了 AOP 中的基础概念(Advice、CutPoint、Advisor等)，目标是为各种AOP实现提供统一的接口，本身并不是一种 AOP 的实现。Spring AOP, GUICE等都采用了AOP Alliance中定义的接口，因而这些lib都需要依赖 aopalliance.jar。  第7步：使用JDK动态代理实现AOP织入      这一步我们就是利用之前说到的动态代理模式，几乎一模一样的完成织入。想一下，我们实现动态代理要用Proxy.newInstance，我们可以封装一个动态代理类，就叫做JdkDynamicAopProxy implements InvocationHandler。由之前的动态代理知识可知，实现了InvocationHandler就必须实现invoke方法，那我们这样写：    @Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {    //        MethodInterceptor methodInterceptor = advised.getMethodInterceptor();    //        return methodInterceptor.invoke(new ReflectiveMethodInvocation(advised.getTargetSource().getTarget(),method,args));        System.out.println("方法开始");        Object result = method.invoke(advised.getTargetSource().getTarget(),args);        System.out.println("方法结束");        return result;}        这样就可以将所有代理方法前后打印两句话了。我们通过getProxy返回构造好的代理类：return Proxy(getClass.getClassLoader,new Class[]{target.getClass},this。因为本类就是InvocationHandler的实现类，因此最后一个用this即可。        我们知道想成功代理一个实例需要2个要素1.被代理的实例2.被代理的接口。我们用AdvisedSupport进行封装，包括target、targetClass（其实应该是targetInterface）（前两个被封装进TargetSource，而TargetSource被封装进AdvisedSupport）、methodInterceptor.等一下，methodInterceptor是个什么吊参数？        按照我们这样写，功能只能是对被代理的方法前后加一句话而已，那有没有一种方式能让我们能定制对方法调用时进行的控制？有，就是MethodInterceptor，即方法拦截器类。          http://aopalliance.sourceforge.net/doc/org/aopalliance/intercept/MethodInterceptor.html                      MethodInterceptor,环绕切点进行织入                    MethodBeforeAdvice，切点前侧织入                    MethodAfterAdvice,切点后侧织入                    ThrowsAdvice,切点的目标方法出现异常时调用                          与上文采用的动态代理不同，我们可以通过配置拦截器来配置不同的代理逻辑。但是注意methodInterceptor.invoke方法中还有个methodInvovation，这个类用于调用我们的target的方法，因此这个类需要target实例，method和args。        所以其实啊MethodInvocation就是point cut，而MethodInterceptor就是advice，Invocation负责调用target方法即切点方法，Interceptor负责代理逻辑即advice。        这一步到此为止可以做到：1.写一个实现MethodInterceptor的实现类，实现增强功能。2.实现对接口方法的代理。    // 1. 设置被代理对象(Joinpoint)AdvisedSupport advisedSupport = new AdvisedSupport();TargetSource targetSource = new TargetSource(car,Driveable.class);advisedSupport.setTargetSource(targetSource);  // 2. 设置拦截器(Advice)TimerInterceptor timerInterceptor = new TimerInterceptor();advisedSupport.setMethodInterceptor(timerInterceptor);  // 3. 创建代理(Proxy)JdkDynamicAopProxy jdkDynamicAopProxy = new JdkDynamicAopProxy(advisedSupport);Driveable carProxy = (Driveable)jdkDynamicAopProxy.getProxy();    // 4. 基于AOP的调用carProxy.running();            给出一个AOP采用的动态代理方式的小demo    class ReflectMethodInvocation implements MethodInvocation{    private Method method;    private Object target;    private Object[] args;    public ReflectMethodInvocation(Method method, Object target, Object[] args) {    this.method = method;    this.target = target;    this.args = args;    }      @Override    public Method getMethod() {        return method;    }      @Override    public Object[] getArguments() {        return args;    }      @Override    public Object proceed() throws Throwable {        return method.invoke(target,args);    }      @Override    public Object getThis() {        return target;    }      @Override    public AccessibleObject getStaticPart() {        return method;    }}  public class JdkAopNew {    public static void main(String[] args) {        Car car = new Car();        MethodInterceptor methodInterceptor = new MethodInterceptor() {            @Override            public Object invoke(MethodInvocation methodInvocation) throws Throwable {                System.out.println("拦截器方式动态代理前");                methodInvocation.proceed();                System.out.println("后");                return null;            }        };        Drivebale drivebale =  (Drivebale) Proxy.newProxyInstance(car.getClass().getClassLoader(), car.getClass().getInterfaces(), new InvocationHandler() {            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {                return methodInterceptor.invoke(new ReflectMethodInvocation(method,car,args));            }        });        drivebale.running();    }}      第8步：使用AspectJ管理切面      第7步解决了怎么织入的问题，下面就是在哪里织入？Spring采用了AspectJ风格的标示性语句来表示在哪些位置进行织入，即哪些位置是point cut。类似下面的语句。Spring可以对类和方法做插入，因此我们也要实现对类和方法表示point cut的功能。        先写出ClassFilter接口和MethodMathcer接口，望文生义的说前者是类过滤器，后者是方法匹配器。具体怎么匹配呢？就在我们的AspectJExpressionPointcut中。        AspectJExpressionPintcut中要做这样几件事1.获得String expression即AspectJ风格表达式2.创建PonitcutParser，即解析AspectJ风格表达式的解析器。3.expression被解析后就变成了pointcutExpression。即expression是输入，pointcutParser是输出，pointcutParser是解析器，将输入解析成输出。这个解析器怎么创建呢？直接new一个行不行啊？不行。正确的创建方式为：pointcutParser = PointcutParser.getPointcutParserSupportingSpecifiedPrimitivesAndUsingContextClassloaderForResolution(supportedPrimitives);后面的supportedPrimitives指的是执行的AspectJ语言风格的关键字，是一个set。那请问支持哪些关键字呢？去org.aspectj.weaver.tools包内的PointPrimitive就可以看奥。        可以看出pointcutExpression是对expression的封装。        pointcutExpression是创建好了，但是有什么用呢？这个类可以用于匹配方法和类。    //匹配类pointcutExpression.couldMatchJoinPointsInType(targetClass);//匹配方法ShadowMatch shadowMatch = pointcutExpression.matchesMethodExecution(method);             所以其实AspectJ包已经帮你做好了解析和匹配的事儿，只不过你不会用他的编译器，你用动态代理的方式实现了织入。            AspectJExpressionPointcutAdvisor封装了pointcut和advice，实现了一个完整的切面，切面=切点+advice。p.s.advice就是代理逻辑代码。  第9.1步：完善Bean的生命周期      生命周期，最后还有一个destroy没有显示出来。        BeanPostProcessor接口（下称BPP接口）是AOP在Bean创建方面的应用——根据Spring的生命周期，BeanPostProcessor是在创建Bean的构造函数，setter方法后。并且所有BPP接口实例都不会受到BPP影响，即BPP的实例过程不会有before和after的影响。            BPP接口实例要率先被实例化，并且实例化过程几乎不会存在依赖ref。        一般实例的创建过程      第9.2步：将AOP融入Bean的创建过程      第7和第8步我们已经完成了AOP的point识别和识别后的织入，但是两个功能没有整合，同时也没有和Spring的IOC整合起来。目的是为了，IOC给我们的容器已经不再是我们自己写的实例，而是被织入了advice的实例——如果该类在pointcut则返回new JdkDynamicAopProxy，否则返回bean。    public Object postProcessAfterInitialization(Object bean, String beanName) throws Exception {	if (bean instanceof AspectJExpressionPointcutAdvisor) {		return bean;	}    if (bean instanceof MethodInterceptor) {        return bean;    }	List&lt;AspectJExpressionPointcutAdvisor&gt; advisors = beanFactory			.getBeansForType(AspectJExpressionPointcutAdvisor.class);	for (AspectJExpressionPointcutAdvisor advisor : advisors) {		if (advisor.getPointcut().getClassFilter().matches(bean.getClass())) {			AdvisedSupport advisedSupport = new AdvisedSupport();			advisedSupport.setMethodInterceptor((MethodInterceptor) advisor.getAdvice());			advisedSupport.setMethodMatcher(advisor.getPointcut().getMethodMatcher());  			TargetSource targetSource = new TargetSource(bean, bean.getClass().getInterfaces());			advisedSupport.setTargetSource(targetSource);  			return new JdkDynamicAopProxy(advisedSupport).getProxy();		}	}	return bean;}                第一幕：和9.1非常类似的，仅有标红出不同。因为AspectJAwareAdvisorAutoProxyCreator implements BBP，BeanFactoryWare，因此不同仅仅是，因为实现了BeanFactoryAware接口，因此调用setFactory方法。这一步的目的是为了是的AspectAwareAdvisorAutoProxyCreator中具有beanFactory，方便从中获取AspectJExpressionPointcutAdvisor.class类的实例。            第二幕：这一幕是目前为止最复杂也最重量级的。相当于把第9.1步和7,8两步合起来了，归纳如下：                  首先因为autoProxyCreator implements BBP,BeanFactoryAware，因此其必然先于所有一般实例和AOP实例创建，而且所有一般实例和AOP实例都必然要经过autoProxyCreator的before和after处理。                    当实例化一般实例和AOP实例时，after中对实例进行检查，如果其肯定不需要代理，比如说是提供代理pointcut与advice的AspectJExpressionPointcutAdvisor或是提供advice的methodInterceptor。如果和expression给出的表达式不匹配的类也不进行代理。对那些对expression匹配的类，就返回proxy类实例代替原来的bean。                    小结：1.先通过BBP接口特性实现每个非BBP实例都必须经过BBP实例的before和after方法。2.正是因为BBP的这种特性，因此after方法中对非BBP实例进行检查，如果和expression表示的point cut匹配则返回代理对象，否则返回原对象。                          第一幕创建BBP实例，以编译对所有非BBP实例进行before、after操作。第二幕通过判断该类是否为point cut从而确认返回原实例还是代理实例，到第二幕已经将实例创建完毕。第三幕指的是，当实例调用接口方法时，如果该方法是pointcut，则会调用如下流程：    invocationHandler.invoke(proxy,method,args)调用methodInterceptor.invoke(methodInvocation)，methodInterceptor内部进行1.代理编码的实现2.函数参数methodInvocation调用proceed，从而执行被代理实例的method方法。因为methodInvocation要可以调用被代理实例的method，因此methodInvocation当你想要实现这个接口时，必须要指定被代理实例target，被代理实例的方法method和参数args。  第9.3步：目前还存在的问题原作者代码中的一个错误  来自Github原项目的Issues中：  https://github.com/code4craft/tiny-spring/issues/10问题是：在进行测试的时候，发现调用非BPP实例的接口方法时，并没有被代理。      什么原因呢？原Issues里面也说了，要加上一句beanDefinition.setBean(bean).这句话是不是有些眼熟？逻辑是这样的：                  先给出非AOP实例（即实例没有pointcut）情况下，这部分的详细逻辑                            再给出有AOP（即有pointcut，需要代理）情况下，这部分的详细逻辑                可以看到，第一次setBean实现了将beanDefinition.bean指向内存空间a。此时bean和beanDefinition.bean指向了同一块内存区域，因此对bean的操作本质上是对内存空间a的操作，而beanDefinition.bean也指向这块内存区域，因此对这块区域propertyvalue的赋值不影响beanDefinition.bean的引用关系。但是！当return new之后，bean已经指向了不同的内存空间b，beanDefinition.bean仍然指向内存空间a，因此需要重新set。            修正错误后带来的新问题  来自Github原项目的Issues中：  https://github.com/code4craft/tiny-spring/issues/17问题是：如果a ref b,b ref a，且顺序也是这样。      这个问题很奇怪。我们看看在实际Spring中的实验效果：                  实验准备：                            实验过程：                            实验一：                        可以看出，单独的calculator和book都可以被正常代理。当然，在TinySpring中也是符合的。                    实验二：                在Spring中，接口实现类根本不用考虑这个问题，因为根本无法运行。逻辑在于，你获得的A和B本质上都是代理类，代理类只实现了代理接口，因此无法强转为某一个具体的实现类。所以A.B.b()和B.A.a()从本质上根本就不会强转成功。                    实验三：        怎么样才能正确进行这个实验呢？上一个回答说到，不能进行实验的本质是因为只能代理接口而不能代理类，所以Spring通过Cglib实现类代理。                通过proxy-target-class标记为true后，强制开启cglib，此时再看实验结果。                成功！                    小结论实验三证明，强制开启Chlib后，可以进行本实验，且Spring解决了循环依赖的问题。那原作者的tiny spring是不是进行第10步之后，就解决了呢？答案是没有，因为Cglib只是让我们的实验可以正常进行，不代表能解决这个问题。Spring是通过三级缓存解决的。                上图是第10步做完后的效果，发现问题还未解决。            只能对接口代理  只能对接口代理，为了对这个问题有深入的认识，我们举出以下两个例子：          例子1：CA implements A。CA类中出了有A接口的a()以外，还有c()，当动态代理后，返回的CA类实例是proxy，因此只能转换为A类型，所以永远无法使用c()。这要求，CA中所有方法必须实现A。      例子2：CA implements A,CB implements B。CA中有CB类型的成员变量，CB中有CA类型的成员变量。抱歉，不行。为什么？因为CA类型实例正在创建的过程中因为ca ref cb会先创建cb，但是cb返回的是proxy实例而不是CB实例，因此proxy实例无法赋值给cb。      第9.4步：万恶之源  万恶之源就是，AOP如果用动态代理实现，从根本上就意味着只能代理接口方法。有没有一种方式可以代理类，而不仅仅是借口呢？抱歉，还真的有。第10步：使用CGLib进行类的织入如何使用CGLib实现动态代理      CGlib的原理是通过对字节码的操作，可以动态的生成一个目标实例类的子类，这个子类和目标实例的子类相同的基础上，还增加了代理代码或者叫advice。代理类 = 被代理类+增强逻辑          CGlib动态代理        class Student{    private String name = "zhang san";      public String getName() {        System.out.println(name);        return name;    }      public void setName(String name) {        this.name = name;    }}public class CglibMthodTwo implements MethodInterceptor {    public Object getProxy(Class clazz){        Enhancer en = new Enhancer();        en.setSuperclass(clazz);        en.setCallback(this);        Object proxy = en.create();        return proxy;    }    @Override    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {        System.out.println("前");        Object res =  methodProxy.invokeSuper(o,objects);        System.out.println("后");        return res;    }      public static void main(String[] args) {        CglibMthodTwo cglibMthodTwo = new CglibMthodTwo();        ((Student)cglibMthodTwo.getProxy(Student.class)).getName();      }  }              JDK动态代理。        public class JdkDynamicAopProxy extends AbstractAopProxy implements InvocationHandler {      public JdkDynamicAopProxy(AdvisedSupport advised) {        super(advised);    }      @Override    public Object getProxy() {        return Proxy.newProxyInstance(getClass().getClassLoader(), advised.getTargetSource().getInterfaces(), this);    }      @Override    public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {        MethodInterceptor methodInterceptor = advised.getMethodInterceptor();        Object res = null;        if (advised.getMethodMatcher() != null                &amp;&amp; advised.getMethodMatcher().matches(method, advised.getTargetSource().getTarget().getClass())) {            res = methodInterceptor.invoke(new ReflectiveMethodInvocation(advised.getTargetSource().getTarget(),                    method, args));        } else {            res = method.invoke(advised.getTargetSource().getTarget(), args);          }        return res;    }  }        与JDK动态代理的区别          原理上JDK没有修改字节码，而是采用$proxyn extend Proxy implements InterfaceXXX的方式创建了一个被代理接口的实现类，然后在运行期写class文件，再用classloader加载。而CGlib却是操作字节码，将被代理类的字节码增强成一个子类，因此要导入ASM包。      操作上，JDK动态代理创建为Proxy类实例，且必须要传入InvocationHandler类，而Cglib创建为Enhancer类实例，且必须传入MethodInterceptor类（注意包的问题，这个MethodInterceptor是CGlib中的）。      Advice即代理代码的实现上，JDK动态代理可以在InvocationHandler中重写invoke实现，或者在InvocationHandler.invoke中调用methodInterceptor.invoke（methodInvocation），将代理的业务代码交给methodInterceptor去做，被代理实例方法的运行通过参数methodInvocation.proceed()实现。而在CGlib中，通过methodInterceptor.intercept()实现代理增强，值得注意的是，这个方法内部有四个参数，包括一个被代理实例，而JDK的InvocationHandler.invoke却不包含被代理实例。      在运行方法上，JDK代理类实例.a()的运行流程为先运行InvocationHandler.invoke,在invoke中运行methodInterceptor.invoke，在这个invoke中有代理逻辑代码和methodInvocation.proceed()，从而实现代理逻辑与被代理实例方法的两开花。而CGlib则是直接运行methodInterceptor.interceptor方法。注意，这一条很重要。            为什么说运行方法上的差异很重要呢，因为这会导致步骤9的代码不可复用。因为我们原来写的都是JDK代理类实例的那一套代码，如果用CGlib的话，就无法通过注入org.aopalliance.intercept.MethodInterceptor的方式实现增强，而是注入cglib的MethodInterceptor，通过setCallback可以设置不同methodInterceptor。有没有一种办法，让我们配置一种org.aopalliance.intercept.MethodInterceptor，在CGlib的情况下也可以调用它呢？        有啊，只要我们在cglib的methodInterceptor接口实现的intercept方法中调用org.aopalliance.intercept.MethodInterceptor不就好了。    private static class DynamicAdvisedInterceptor implements MethodInterceptor {      private AdvisedSupport advised;      private org.aopalliance.intercept.MethodInterceptor delegateMethodInterceptor;      private DynamicAdvisedInterceptor(AdvisedSupport advised) {        this.advised = advised;        this.delegateMethodInterceptor = advised.getMethodInterceptor();    }      @Override    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {        if (advised.getMethodMatcher() == null                || advised.getMethodMatcher().matches(method, advised.getTargetSource().getTargetClass())) {            // return delegateMethodInterceptor.invoke(new ReflectiveMethodInvocation(advised.getTargetSource().getTarget()，method, args));            return delegateMethodInterceptor.invoke(new CglibMethodInvocation(advised.getTargetSource().getTarget(), method, args, proxy));        }        // return method.invoke(advised.getTargetSource().getTarget(),args);可以这么写，        return new CglibMethodInvocation(advised.getTargetSource().getTarget(), method, args, proxy).proceed();    }}        现在只剩下一个疑问了，因为么要写一个ReflectMothodInvocation的子类？因为intercept有4个入参，所以我们交给下一步处理的时候也要有4个入参，相当于增强了一下功能，当然你这边不改也没问题，就当做JDK那个版本就行。  第11步：通过三级缓存彻底解决循环依赖      废话少说，先看结果    @Testpublic void testXuhuanyilai() throws Exception {    // --------- helloWorldService without AOP    ApplicationContext applicationContext = new ClassPathXmlApplicationContext("tinyioc.xml");    Car car = (Car) applicationContext.getBean("car");    car.getAddress().living();    Address address = (Address)applicationContext.getBean("address");    address.getCar().running();}//测试结果Invocation of Method setCar start!Invocation of Method setCar end! takes 123111 nanoseconds.Invocation of Method setAddress start!Invocation of Method setAddress end! takes 38666 nanoseconds.Invocation of Method running start!car is runningInvocation of Method running end! takes 45777 nanoseconds.Invocation of Method living start!address is livingInvocation of Method living end! takes 56000 nanoseconds.        实验结果表示，我已经解决了第9.3步中说到的AOP情况下，循环依赖导致a ref b, b ref a时，创建实例时，b.a指向的是空实例a，而不是代理实例a。        解决方法。                  三层缓存。        protected Map&lt;String,Object&gt; secondCache = new HashMap();protected Map&lt;String,Object&gt; thirdCache = new HashMap&lt;&gt;();protected Map&lt;String,Object&gt; firstCache = new HashMap&lt;&gt;();                            thirdCache是当空构造函数创建一个实例时，就放入其中。        protected Object doCreateBean(String name,BeanDefinition beanDefinition) throws Exception {    Object bean = createBeanInstance(beanDefinition);    thirdCache.put(name,bean);//thirdCache中放置的全是空构造方法构造出的实例    beanDefinition.setBean(bean);    applyPropertyValues(bean,beanDefinition);    return bean;}                            a ref b, b ref a情况下，在b创建时，a还只是空构造实例，因此用secondCache去保存所有field中指向空实例的那些实例，即保存b。        for(PropertyValue propertyValue:mbd.getPropertyValues().getPropertyValues()){Object value = propertyValue.getValue();if(value instanceof BeanReference){//如果是ref，就创建这个ref    BeanReference beanReference = (BeanReference)value;    value = getBean(beanReference.getName());    String refName = beanReference.getName();    if(thirdCache.containsKey(refName)&amp;&amp;!firstCache.containsKey(refName)){//说明当前是循环依赖状态        secondCache.put(beanReference.getName(),bean);//标注a ref b,b ref a中，b是后被循环引用的    }}                            firstCache用于保存所有最终被生成的实例.        initializeBean():if(thirdCache.containsKey(name)){//空构造实例如果被AOP成代理实例，则放入三级缓存，说明已经构建完毕    firstCache.put(name,bean);}                            因此，当执行完方法beanFactory.preInstantiateSingletons();后，thirdCache保存了所有空构造实例及名称，secondCache保存了所有可能需要重新设置ref的实例及名称，first保存了所有最终生成的实例和名称。在firstcache与third中，必然存放了所有的bean，在second中只存放因循环依赖所以创建时ref了不完整对象的那些。在创建了所有实力后，通过checkoutAll方法对secondCache中的实例进行重置依赖。        protected void onRefresh() throws Exception{    beanFactory.preInstantiateSingletons();    checkoutAll();}    private void checkoutAll(){    Map&lt;String,Object&gt; secondCache = beanFactory.getSecondCache();    Map&lt;String,BeanDefinition&gt; beanDefinitionMap = beanFactory.getBeanDefinitionMap();    for(Map.Entry&lt;String,Object&gt; entry:secondCache.entrySet()){        String invokeBeanName = entry.getKey();        BeanDefinition beanDefinition = beanDefinitionMap.get(invokeBeanName);        try {            resetReference(invokeBeanName,beanDefinition);        } catch (Exception e) {            e.printStackTrace();        }    }}//重置依赖，这边用到了动态类型转换。因为原类型的setter在代理类中已经无法使用了。private void resetReference(String invokeBeanName,BeanDefinition beanDefinition) throws Exception {    Map&lt;String,Object&gt; thirdCache = beanFactory.getThirdCache();    Map&lt;String,Object&gt; secondCache = beanFactory.getSecondCache();    Map&lt;String,Object&gt; firstCache = beanFactory.getFirstCache();    Map&lt;String,BeanDefinition&gt; beanDefinitionMap = beanFactory.getBeanDefinitionMap();    for (PropertyValue propertyValue : beanDefinition.getPropertyValues().getPropertyValues()) {        String refName = propertyValue.getName();        if (firstCache.containsKey(refName)) {//如果是ref，就创建这个ref            Object exceptedValue = firstCache.get(refName);            Object invokeBean = beanDefinition.getBean();            Object realClassInvokeBean = thirdCache.get(invokeBeanName);            Object realClassRefBean = thirdCache.get(refName);            try{                Method declaredMethod = realClassInvokeBean.getClass().getDeclaredMethod("set" + propertyValue.getName().substring(0, 1).toUpperCase()                        + propertyValue.getName().substring(1), realClassRefBean.getClass());                declaredMethod.setAccessible(true);                declaredMethod.invoke((realClassInvokeBean.getClass().cast(invokeBean)), (realClassRefBean.getClass().cast(exceptedValue)));            }catch (NoSuchMethodException e){                Field declaredField = realClassInvokeBean.getClass().getDeclaredField(propertyValue.getName());                System.out.println(declaredField);                declaredField.setAccessible(true);                declaredField.set((realClassInvokeBean.getClass().cast(invokeBean)), (realClassRefBean.getClass().cast(exceptedValue)));            }        }    }}                          正如在9.3中说的那样，只有在开启全局cglib的情况下才可以完成本实验，如果开启jdk代理模式或者jdk代理+cglib都不会解决本bug。  小结  IOC中通过读xml用一个map，读完才赋值给beanFactory的map的方式避免了xml因顺序问题而导致的注入失败。  IOC中通过getBean懒加载+先空构造器创建实例的方式解决了循环依赖的问题（简单解决而已，还未能解决增加AOP功能后循环依赖的问题。）。  IOC本身1.因为都是注入，而不是在某一个类中new，因此系统耦合降低，所有的创建交给第三方容器，类似工厂模式2.IOC类的提供只需要xml注册，创建的具体细节不需要你知道，程序更易维护和使用，因为你写的代码别人只要xml里注册一下就能用你的实例。3.解决了对象层级嵌套的问题，a ref b,b ref c,c ref a,d ref b这样复杂的嵌套关系，应该如何初始化？交给Spring！  AOP中通过jdk动态代理模式实现了被代理实例代理方法的织入。  AOP中通过AspectJ包完成了对AspectJ风格expression的解析，进一步完成了对类和方法ponitcut的判断。  AOP中通过BeanPostProcessor接口实现了一个完成的bean的生命周期中after和before的工作，这个并不是通过AOP完成的，而是通过逻辑代码的流程控制完成的：确保所有实现BeanPostProcessor接口的实例都率先实例化。  AOP中，所有ProxyCreator都实现BeanPostProcessor接口和BeanFactoryAware接口。前者接口保证自己率先被实例化，以保证对非AOP实例的before和after处理，后者接口保证在初始化自己的时候，会setBeanFactory，以用于后面获取切面。  AOP中，所有非AOP实例都必须经过ProxyCreator的after方法，proxyCreator中已经有了beanFactory，因此可以获得所有expression对应的类pointcut，只要实例对应的类匹配类pointcut，就返回代理类实例而不是原实例。至此，全部实例创建工作完毕。  AOP中，所有非AOP实例运行接口方法时，会按照invocationHandler.invoke(methodInterceptor.invoke(methodInvocation))逻辑进行调用，从而实现织入。  AOP中，因为JDK代理只能针对接口，因此引入Cglib技术，实现类的动态代理。通过在cglib包的methodInterceptor中调用org.aopalliance.intercept.MethodInterceptor，实现了xml中配置的methodInterceptor对接口和类都可以使用。  AOP中，最终通过三级缓存彻底解决了单例setter注入下的循环依赖。]]></content>
      <categories>
        
          <category> Java </category>
        
      </categories>
      <tags>
        
          <tag> Spring </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[给h5ai开启二维码、搜索、选择功能]]></title>
      <url>/%E6%8A%80%E6%9C%AF,/linux/2019/03/21/h5ai-pro/</url>
      <content type="text"><![CDATA[说明：现在越来越多的人使用h5ai了，毕竟精巧，美观等，之前介绍过h5ai安装方法，参考：一款不错的PHP目录列表程序：h5ai安装教程，其实有的人虽然用上了，可是却不知道里面还有很多功能都没使用上，这里就说下开启其中几种适用的功能方法。方法以下均在配置文件/www.xx.com/_h5ai/private/conf/options.json修改1、开启选择功能"select": {        "enabled": false,        "clickndrag": true,        "checkboxes": true    },将false修改为true，即："select": {        "enabled": true,        "clickndrag": true,        "checkboxes": true    },该功能可方便我们进行批量下载。2、开启搜索功能"search": {        "enabled": false,        "advanced": true,        "debounceTime": 300,        "ignorecase": true    },将false修改为true，即："search": {        "enabled": true,        "advanced": true,        "debounceTime": 300,        "ignorecase": true    },开启后我们可以更快的找到文件了。3、开启二维码功能"info": {        "enabled": false,        "show": false,        "qrcode": true,        "qrFill": "#999",        "qrBack": "#fff"    },将false修改为true，即："info": {        "enabled": true,        "show": true,        "qrcode": true,        "qrFill": "#999",        "qrBack": "#fff"    },开启二维码后，我们可以直接手机扫描二维码下载，很方便。原文链接：https://www.moerats.com/archives/395/]]></content>
      <categories>
        
          <category> 技术, </category>
        
          <category> linux </category>
        
      </categories>
      <tags>
        
          <tag> linux, </tag>
        
          <tag> vps, </tag>
        
          <tag> 技术 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[VPS允许root免密登录]]></title>
      <url>/posts/2019-03-20-enable-vps-root</url>
      <content type="text"><![CDATA[配置vps# 将本地主机的ssh公钥粘贴在/root/.ssh/authorized_keys# 如上图所示sudo -i vi /etc/ssh/sshd_config修改# Authentication:PermitRootLogin yes //默认为no，需要开启root用户访问改为yes# Change to no to disable tunnelled clear text passwordsPasswordAuthentication yes //默认为no，改为yes开启密码登陆passwd root/etc/init.d/ssh restart本地新建config在~/.ssh.config中host ecs   user root   hostname 47.117.128.212   port 22   identityfile ~/.ssh/id_rsa这样本地主机就可以不用输入ip和密码直接用ssh ecs登录vps了]]></content>
      <categories>
        
          <category> 技术, </category>
        
          <category> linux </category>
        
      </categories>
      <tags>
        
          <tag> linux, </tag>
        
          <tag> vps, </tag>
        
          <tag> 技术 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[解决阿里云Debian新机update问题]]></title>
      <url>/posts/2019-03-19-fix-debian-update</url>
      <content type="text"><![CDATA[  阿里云自带了一些无用的安全源，删除掉即可（ubuntu/debian系统）rm -rf /root/.pip /root/.pydistutils.cfg /etc/apt/sources.list.d/sources-aliyun-0.list /etc/apt/sources.list.d/sources-aliyun* /var/lib/apt/lists/*   根据阿里云官方源的建议，修改源deb http://mirrors.cloud.aliyuncs.com/debian/ jessie main contrib non-freedeb-src http://mirrors.cloud.aliyuncs.com/debian/ jessie main contrib non-freedeb http://mirrors.cloud.aliyuncs.com/debian/ jessie-proposed-updates main non-free contribdeb-src http://mirrors.cloud.aliyuncs.com/debian/ jessie-proposed-updates main non-free contribdeb http://mirrors.cloud.aliyuncs.com/debian/ jessie-updates main contrib non-freedeb-src http://mirrors.cloud.aliyuncs.com/debian/ jessie-updates main contrib non-free ## Uncomment the following two lines to add software from the 'backports'## repository.#### N.B. software from this repository may not have been tested as## extensively as that contained in the main release, although it includes## newer versions of some applications which may provide useful features.#deb http://mirrors.cloud.aliyuncs.com/debian/ jessie-backports main contrib non-free#deb-src http://mirrors.cloud.aliyuncs.com/debian/ jessie-backports main contrib non-free  更新镜像，搞定apt-get cleanapt-get update套路云还是套路云，服气！！！]]></content>
      <categories>
        
          <category> 技术, </category>
        
          <category> linux </category>
        
      </categories>
      <tags>
        
          <tag> linux, </tag>
        
          <tag> vps, </tag>
        
          <tag> 技术 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Jekyll 博客 Netlify CMS 后台部署]]></title>
      <url>/posts/2019-03-18-jekyll-netlify-cms-admin</url>
      <content type="text"><![CDATA[  netlify 后台：https://app.netlify.com/  netlify config 配置文档：https://www.netlifycms.org/docs/intro/  Github OAuth网址：https://github.com/settings/developers获取Client ID和Secret在 Github OAuth 页面新建一个 app 获取 Client ID和Secret其中Authorization callback URL必须填这个：https://api.netlify.com/auth/done ，其余随意。去netlify  后台绑定 GitHub 的 repositorie绑定成功是这个样子的：这个时候出现的错误暂时不要管。setting-&gt;Domain management ，添加github自带的二级域名，如果在github上面自定义了域名，也要加上，不要管 DNS 验证.在GitHub新建netlify分支内容可以参考我的 netlify 分支，其中 config.yml文件里的域名改成你的github 二级域名，如果自定义了域名请填自定义的域名在主分支master创建admin文件夹admin ├ index.html └ config.yml我的就是：admin配置admin里的config我这个jekyll只用到发布文章的post，所以后台也只需要这个简单的功能，只需要加一点这个文章头部的选项，每个人不一样，需要自己写。官方文档可以参考：netlifycms-docs!到这里，GitHub仓库的修改基本上完成了。去 netlify 后台配置编译setting-&gt;Buil &amp; deploy-&gt;Deploy contexts，将Production branch改成netlify分支，将Branch deploys改成master分支。然后就可以编译了：登录博客后台进入 https://网站域名/admin 后台登陆，大概就是这样子。]]></content>
      <categories>
        
          <category> 博客, </category>
        
          <category> Jekyll </category>
        
      </categories>
      <tags>
        
          <tag> jekyll, </tag>
        
          <tag> jetlify-cms </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[✍GitBook👉高级配置]]></title>
      <url>/%E6%8A%80%E6%9C%AF/2018/08/26/use-gitbook/</url>
      <content type="text"><![CDATA[  先留链接防丢失：      gitbook-use    使用GitBook打造自己的出版平台  安装💦  NodeJS(v4.0.0及以上)  npm install gitbook-cli -g ， gitbook-cli是gitbook的一个命令行工具, 通过它可以在电脑上安装和管理gitbook的多个版本.  预览书籍：          gitbook serve : 在书籍的文件夹中生成一个 _book 文件夹，里面的内容即为生成的 html 文件， 通过http://localhost:4000/可以预览书籍。      gitbook build : 仅生成 _book 里的html，不开启服务器。      常用命令💦      gitbook-cli 和 gitbook 是两个软件;    gitbook-cli 会将下载的 gitbook 的不同版本放到 ~/.gitbook中, 可以通过设置GITBOOK_DIR环境变量来指定另外的文件夹.    生成静态网页：gitbook build  生成静态网页并运行服务器: gitbook serve  生成时指定gitbook的版本, 本地没有会先下载: gitbook build ----gitbook=2.6.7  列出本地所有的gitbook版本: gitbook ls  列出远程可用的gitbook版本: gitbook ls-remote  更新到gitbook的最新版本: gitbook update  卸载对应的gitbook版本: gitbook uninstall 2.6.7目录结构💦.├── book.json├── README.md├── SUMMARY.md├── chapter-1/|   ├── README.md|   └── something.md└── chapter-2/    ├── README.md    └── something.mdSummary💦示例1：以后会经常用到的# Summary* [Introduction](README.md)-------------------------------1.1----### [Part I](folder1/README.md)* [Writing is nice](folder1/writing.md)-------------------2.1.* [GitBook is nice](folder1/gitbook.md)-------------------2.2.### Part II* [We love feedback](folder2/feedback_please.md)----------3.1.* [Better tools for authors](folder2/better_tools.md)-----3.2.----* [Last part without title](title.md)---------------------4.1.示例2：以后会用的但不常用的# Summary### Part I(part1/README.md)---------------------------1.* [section1](part1/section1/README.md)----------------1.1.	* [Writing is nice](part1/section1/writing.md)----1.1.1	* [GitBook is nice](part1/section1/gitbook.md)----1.1.2* [We love feedback](part1/title1.md)-----------------1.2* [Better tools for authors](part1/title2.md)---------1.3示例3：最简版本# Summary### Part I* [Introduction](README.md)* [Writing is nice](writing.md)* [GitBook is nice](gitbook.md)### Part II* [We love feedback](feedback_please.md)* [Better tools for authors](better_tools.md)Glossary💦GLOSSARY.md。该文件主要存储词汇信息，如果在其他页面中出现了该文件中的词汇，鼠标放到词汇上会给出词汇示意。GLOSSARY.md 格式：## Git-----------------词汇分散式版本控制软件--------词汇示意## MarkdownAaron Swartz 跟John Gruber共同设计的排版语言book.json💦book.json 最重要，故单独作为一节。title：设置书本的标题💦"title" : "Gitbook Use"author：作者的相关信息💦"author" : "ds"description：本书的简单描述💦"description" : "记录Gitbook的配置和一些插件的使用"language：Gitbook使用的语言💦版本2.6.4中可选的语言如下：en, ar, bn, cs, de, en, es, fa, fi, fr, he, it, ja, ko, no, pl, pt, ro, ru, sv, uk, vi, zh-hans, zh-tw配置使用简体中文:"language" : "zh-hans",gitbook: 指定使用的gitbook版本💦"gitbook" : "3.2.2","gitbook" : "&gt;=3.0.0"root：指定根目录💦"root": "."links：左侧导航栏添加链接信息💦"links" : {    "sidebar" : {        "个人主页" : "http://www.ds-vip.top"    }}styles：自定义页面样式💦默认情况下各generator对应的css文件："styles": {    "website": "styles/website.css",    "ebook": "styles/ebook.css",    "pdf": "styles/pdf.css",    "mobi": "styles/mobi.css",    "epub": "styles/epub.css"}例如使&lt;h1&gt; &lt;h2&gt;标签有下边框， 可以在website.css中设置，这个可以有。h1 , h2{    border-bottom: 1px solid #EFEAEA;}plugins：配置使用的插件💦"plugins": [    "disqus"]  例如上面添加disqus插件：之后需要运行gitbook install来安装新的插件。  Gitbook默认带有5个插件：highlight、search、sharing、font-settings、livereload  如果要去除自带的插件， 可以在插件名称前面加-："plugins": [    "-search"]pluginsConfig：配置插件的属性💦"pluginsConfig": {    "fontsettings": {        "theme": "sepia",        "family": "serif",        "size":  1    }}上面就是配置Gitbook界面那个A按钮的默认属性。structure💦指定 Readme、Summary、Glossary 和 Languages 对应的文件名，下面是这几个文件对应变量以及默认值：            变量      含义和默认值                  structure.readme      Readme file name (defaults to README.md)              structure.summary      Summary file name (defaults to SUMMARY.md)              structure.glossary      Glossary file name (defaults to GLOSSARY.md)              structure.languages      Languages file name (defaults to LANGS.md)      GitBook插件💦可以指定插件的版本可以使用 plugin@0.3.1 ， 下面的插件在 GitBook 的 3.2.3 版本中可以正常工作，插件官网。具体介绍看这里：https://github.com/zhangjikai/gitbook-use/blob/master/plugins.md  Summary插件：npm install -g gitbook-summary  book sm，一个完整的目录文件SUMMARY.md就生成了 ，之后根据自己的需要修改，进一步的命令就不需要了。主题💦我们常用的就是 Book 文档模式，所以只看这部分。theme-default💦默认的 Book 主题。将 showLevel 设为 true， 就可以显示标题前面的数字索引，默认不显示。{    "theme-default": {        "showLevel": true    }}theme-comscore💦这个主题为标题添加了颜色{"plugins": [        "theme-comscore"    ]}book.json配置文件💦  👉看这里]]></content>
      <categories>
        
          <category> 技术 </category>
        
      </categories>
      <tags>
        
          <tag> GitBook </tag>
        
          <tag> 技术 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Emoji😆😆😆]]></title>
      <url>/%E7%B4%A0%E6%9D%90/interesting/2018/08/25/emojicopy/</url>
      <content type="text"><![CDATA[  官网地址：emojicopy  声明：此emoji仅限个人使用，绝不涉及商业范畴，如有侵权，可直接联系我，立马删除😇😇😇。😀😃😄😁😆😅😂🤣☺😊😇🙂🙃😉😌😍😘😗😙😚😋😛😝😜🤪🤨🧐🤓😎🤩😏😒😞😔😟😕🙁☹😣😖😫😩😢😭😤😠😡🤬🤯😳😪🤤😴😲😮😧😦😯🙄😬😑😐😶🤥🤫🤭🤔🤗😓😥😰😨😱😵🤐🤢🤮🤧😷🤒🤕🤑🤠😈👿👹👺🤡💩👻💀☠👽👾🤖🎃😺😸😹😻😼😽🙀😿😾🤲👐🙌👏🤝👍👎👊✊🤛🤜🤞✌🤟🤘👌👈👉👆👇☝🤚🖐🖖👋🤙💪🖕✍🙏🐤🐣🐥🌞🐒🙊🐶🙉🙈🐵☀⛅🌥☁🌦🌧⛈🌩🌨❄⭐⭐⭐💦💦🦉🦉🍉🍑🍌🎻🎖🏅🥉🎸🎺🎷🥁🚲🚗🚔✈🛫🛩🔪🗡⚔🚬💊🔨🎎❤💛🧡💔]]></content>
      <categories>
        
          <category> 素材 </category>
        
          <category> interesting </category>
        
      </categories>
      <tags>
        
          <tag> interesting </tag>
        
          <tag> emoji </tag>
        
          <tag> 素材 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Google技巧😍]]></title>
      <url>/%E6%8A%80%E6%9C%AF/2018/08/22/google-tips/</url>
      <content type="text"><![CDATA[  留个链接：      Google搜索命令    Google搜索帮助    科学上网漫游指南    科学上网    科学上网总结    自建梯子教程    如何翻墙    科学上网相关知识总结  先娱乐一下😴1、搜索“399999999999999-399999999999998”。你将会得到0。2、搜索“do a barrel roll”或者“Z or R twice”，让你的页面旋转360°3、搜索”the Answer to Life, the Universe and Everything”。生命，宇宙以及一切的答案是什么？是42！4、搜索”zerg rush”。会从页面上方降下很多圆圈，每个圆圈你都要三击它们才会将它们消灭，不然随着圆圈的降落，它们会把搜索出来的结果一个个融化掉，最后剩下空白的页面。圆圈正在融化搜索结果中。全部融化完毕，剩下空白的页面。5、搜索“Google in 1998”，你就可以看到1998年的谷歌究竟是长什么样子的。6、搜索“Google Gravity”，让你无视牛顿万有引力。单击红色方框的网站。你将看到Google所有的东西都克服了万有引力，全部瘫倒在地了，尽情地虐待它们吧！！！7、搜索“Google Sphere”，，你将会看到所有的东西围绕Google Search旋转。点击红色方框的网站。它们都在旋转中。8、搜索”Google Pacman”，你就可以在网页上玩一个类似于贪吃蛇的小游戏，但是你要尽量避免碰到那些彩色的东西，因为它们会把你吃掉。点击“Click to Play”这个游戏主要是利用上下左右的方向键进行操作的，请你尽情享受。9、在Google images搜索“atari breakout”这个游戏是不是始（shi)料(niao)未及？好好玩耍吧。SEO相关技巧  熟悉正则表达式很重要。1、双引号 ""把搜索词放在双引号中，代表完全匹配搜索，也就是说搜索结果返回的页面包含双引号中出现的所有的词，连顺序也必须完全匹配。bd和Google 都支持这个指令。例如搜索： “seo方法图片”2、减号-减号代表搜索不包含减号后面的词的页面。使用这个指令时减号前面必须是空格，减号后面没有空格，紧跟着需要排除的词。Google 和bd都支持这个指令。例如：搜索 -引擎返回的则是包含“搜索”这个词，却不包含“引擎”这个词的结果3、星号 *星号是常用的通配符，也可以用在搜索中。百度不支持号搜索指令。比如在Google 中搜索：搜索擎其中的号代表任何文字。返回的结果就不仅包含“搜索引擎”，还包含了“搜索收擎”，“搜索巨擎”等内容。4、inurlinurl: 指令用于搜索查询词出现在url 中的页面。bd和Google 都支持inurl 指令。inurl 指令支持中文和英文。比如搜索：inurl:搜索引擎优化返回的结果都是网址url 中包含“搜索引擎优化”的页面。由于关键词出现在url 中对排名有一定影响，使用inurl:搜索可以更准确地找到竞争对手。5、inanchorinanchor:指令返回的结果是导入链接锚文字中包含搜索词的页面。百度不支持inanchor。比如在Google 搜索 ：inanchor:点击这里返回的结果页面本身并不一定包含“点击这里”这四个字，而是指向这些页面的链接锚文字中出现了“点击这里”这四个字。可以用来找到某个关键词的竞争对收，而且这些竞争对手往往是做过SEO 的。研究竞争对手页面有哪些外部链接，就可以找到很多链接资源。6、intitleintitle: 指令返回的是页面title 中包含关键词的页面。Google 和bd都支持intitle 指令。使用intitle 指令找到的文件是更准确的竞争页面。如果关键词只出现在页面可见文字中，而没有出现在title 中，大部分情况是并没有针对关键词进行优化，所以也不是有力的竞争对手。7、allintitleallintitle:搜索返回的是页面标题中包含多组关键词的文件。例如 ：allintitle:SEO 搜索引擎优化就相当于：intitle:SEO intitle:搜索引擎优化返回的是标题中中既包含“SEO”，也包含“搜索引擎优化”的页面8、allinurl与allintitle: 类似。allinurl:SEO 搜索引擎优化就相当于 ：inurl:SEO inurl:搜索引擎优化9、filetype用于搜索特定文件格式。Google 和bd都支持filetype 指令。比如搜索filetype:pdf SEO返回的就是包含SEO 这个关键词的所有pdf 文件。10、sitesite:是SEO 最熟悉的高级搜索指令，用来搜索某个域名下的所有文件。11、linkdomainlinkdomain:指令只适用于雅虎，返回的是某个域名的反向链接。雅虎的反向链接数据还比较准确，是SEO 人员研究竞争对手外部链接情况的重要工具之一。比如搜索linkdomain:http://cnseotool.com -site:http://cnseotool.com得到的就是点石网站的外部链接，因为-site:http://cnseotool.com 已经排除了点石本身的页面，也就是内部链接，剩下的就都是外部链接了。12、relatedrelated:指令只适用于Google，返回的结果是与某个网站有关联的页面。比如搜索related:http://cnseotool.com我们就可以得到Google 所认为的与点石网站有关联的其他页面。 这种关联到底指的是什么，Google 并没有明确说明，一般认为指的是有共同外部链接的网站。高级技巧日常生活类。1、搜索语法：weather／time／sunrise／sundown+城市名（英语）。即时结果：返回各个城市的天气／所在时区的时间／日出时间／日落时间。例如：weather／time／sunrise／sundown guangzhou(广州），就可以即时看到广州的天气、时间、日出日落时间。2、搜索语法：歌手名字(英语）+music/songs 即时结果：返回歌手的各首歌曲。例如：Jay Chow music3、搜索语法：国家（英语）/省+capital 即时结果：返回这个国家的首都或者省会例如：Guangdong capital，广东的省会即为广州。4、搜索语法：[货币一]+in+[货币二]即时结果：返回货币一可以兑换多少货币二，还能给出汇率的走势。你也可以在搜索栏中直接将各种货币相加，e.g:100usd+50eur+250inr=rmb，就可以直接得出多少人民币。例如：1 usd in rmb甚至可以进行计算：100usd+50eur+250inr=rmb5、搜索语法：Set timer XX seconds/minutes/hours，XX表示具体的数字。即时结果：设置XX秒/分/小时的计时器。例如：set timer 30 minutes，设置倒数时间为30分钟的计时器。6、搜索语法：城市名+to+城市名+distance即时结果：返回两个城市相距的距离。例如：Paris to Rome distance，即时看到巴黎到罗马的距离。7、搜索语法：what’s my location/IP 即时结果：返回你所在的地址以及电脑的IP地址。学术类各国的GDP增长率搜索语法：country GDP growth。例如搜索“Japan GDP growth”和“China GDP growth”。嗯，不错，一对比就知道我天朝一派欣欣向荣。（数据来源于世界银行）😍👍绘制多元方程以及复杂的方程式搜索语法：graph for +方程式子例如：graph for x^8，graph for sin(x)+tan(x)，graph for x^8+y^8。请你多多探索。追踪词汇的来源以及演变搜索语法：Word etymology，word代表你想要搜索的单词。例如：coffee etymology。你就可以看到咖啡这个单词是怎么演变的了。搜索透明图片透明图片，就是不要白底的那种。明天继续更新。。。]]></content>
      <categories>
        
          <category> 技术 </category>
        
      </categories>
      <tags>
        
          <tag> 科学上网 </tag>
        
          <tag> google </tag>
        
          <tag> 教程 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[TCP/IP协议😇]]></title>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2018/08/22/tcp-ip/</url>
      <content type="text"><![CDATA[TCP/IP协议TCP/IP不是一个协议，而是一个协议族的统称。里面包括IP协议、IMCP协议、TCP协议。TCP/IP分层：这里有几个需要注意的知识点：  互联网地址：也就是IP地址，一般为网络号+子网号+主机号  域名系统：通俗的来说，就是一个数据库，可以将主机名转换成IP地址  RFC：TCP/IP协议的标准文档  端口号：一个逻辑号码，IP包所带有的标记  Socket：应用编程接口数据链路层的工作特性：  为IP模块发送和接收IP数据报  为ARP模块发送ARP请求和接收ARP应答（ARP：地址解析协议，将IP地址转换成MAC地址）  为RARP发送RARP请求和接收RARP应答接下来我们了解一下TCP/IP的工作流程：数据链路层从ARP得到数据的传递信息，再从IP得到具体的数据信息IP协议IP协议头当中，最重要的就是TTL（IP允许通过的最大网段数量）字段（八位），规定该数据包能穿过几个路由之后才会被抛弃。IP路由选择ARP协议工作原理ICMP协议（网络控制文协议）将IP数据包不能传送的错误信息传送给主机查询报文  ping查询：主机是否可达，通过计算间隔时间和传送多少个包的数量  子网掩码  时间戳：获得当前时间差错报文不产生的情况：  ICMP差错报文不产生差错报文  源地址为零地址、环目地址、广播地址、多播地址IP路由器选择协议静态路由选择先来看路由选择工作流程：  配置接口以默认方式生成路由表项，或者使用route add手动添加表项  ICMP报文（ICMP重定向报文）更新表项  动态路由选择（只使用在路由之间）RIP（路由信息协议）分布式的基于距离向量（路由器到每一个目的网络的距离记录）的路由选择协议router承担的工作：  给每一个已知路由器发送RIP请求报文，要求给出完整的路由表  如果接受请求，就将自己的路由表交给请求者；如果没有，就处理IP请求表项（自己部分+跳数/没有的部分+16）  接受回应，更新路由表  定期更新路由表（一般为30s，只能说太频繁~）OSPF（开放最短路径优先协议）分布式链路状态（和这两个路由器都有接口的网络）协议  当链路状态发生变化时，采用可靠的洪泛法，向所有的路由器发送信息（相邻的所有路由器的链路状态）  最终会建立一个全网的拓扑结构图TCP/IP的三次握手，四次分手首先我们先来了解TCP报文段：三次握手的过程客户端我们用A表示，服务器端用B表示，前提：A主动打开，B被动打开。  在建立连接之前，B先创建TCB（传输控制块），准备接受客户进程的连接请求，处于LISTEN（监听）状态  A首先创建TCB，然后向B发出连接请求，SYN置1，同时选择初始序号seq=x，进入SYN-SEND（同步已发送）状态  B收到连接请求后向A发送确认，SYN置1，ACK置1，同时产生一个确认序号ack=x+1。同时随机选择初始序号seq=y，进入SYN-RCVD（同步收到）状态  A收到确认连接请求后，ACK置1，确认号ack=y+1，seq=x+1，进入到ESTABLISHED（已建立连接）状态。向B发出确认连接，最后B也进入到ESTABLISHED（已建立连接）状态。简单来说，就是  建立连接时，客户端发送SYN包（SYN=i）到服务器，并进入到SYN-SEND状态，等待服务器确认  服务器收到SYN包，必须确认客户的SYN（ack=i+1）,同时自己也发送一个SYN包（SYN=k）,即SYN+ACK包，此时服务器进入SYN-RECV状态  客户端收到服务器的SYN+ACK包，向服务器发送确认报ACK（ack=k+1）,此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手在此穿插一个知识点就是SYN攻击，那么什么是SYN攻击？发生的条件是什么？怎么避免？在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是 Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址 是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网 络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：  #netstat -nap | grep SYN_RECV四次分手的过程客户端我们用A表示，服务器端用B表示。由于TCP连接时是全双工的，因此每个方向都必须单独进行关闭。这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的链接。收到一个FIN只是意味着这一方向上没有数据流动，既不会在收到数据，但是在这个TCP连接上仍然能够发送数据，知道这一方向也发送了FIN，首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。前提：A主动关闭，B被动关闭为什么连接的时候是三次握手，而断开连接的时候需要四次挥手？这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再 发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。  A发送一个FIN，用来关闭A到B的数据传送，A进入FIN_WAIT_1状态。  B收到FIN后，发送一个ACK给A，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），B进入CLOSE_WAIT状态。  B发送一个FIN，用来关闭B到A的数据传送，B进入LAST_ACK状态。  A收到FIN后，A进入TIME_WAIT状态，接着发送一个ACK给B，确认序号为收到序号+1，B进入CLOSED状态，完成四次挥手。简单来说就是  客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送（报文段4）。  服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（报文段5）。和SYN一样，一个FIN将占用一个序号。  服务器B关闭与客户端A的连接，发送一个FIN给客户端A（报文段6）。  客户端A发回ACK报文确认，并将确认序号设置为收到序号加1（报文段7）。A在进入到TIME-WAIT状态后，并不会马上释放TCP，必须经过时间等待计时器设置的时间2MSL（最长报文段寿命），A才进入到CLOSED状态。为什么？  为了保证A发送的最后一个ACK报文段能够到达B  防止“已失效的连接请求报文段”出现在本连接中总结三次握手流程  客户端发个请求“开门呐，我要进来”给服务器  服务器发个“进来吧，我去给你开门”给客户端  客户端有很客气的发个“谢谢，我要进来了”给服务器四次挥手流程  客户端发个“时间不早了，我要走了”给服务器，等服务器起身送他  服务器听到了，发个“我知道了，那我送你出门吧”给客户端，等客户端走  服务器把门关上后，发个“我关门了”给客户端，然后等客户端走（尼玛~矫情啊）  客户端发个“我知道了，我走了”，之后自己就走了。]]></content>
      <categories>
        
          <category> 计算机基础 </category>
        
      </categories>
      <tags>
        
          <tag> TCP/IP </tag>
        
          <tag> 计算机网络 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[了解门罗币]]></title>
      <url>/%E5%8C%BA%E5%9D%97%E9%93%BE/2018/08/22/start-monero/</url>
      <content type="text"><![CDATA[  参考：《区块链教程》根据 Monero（门罗） 官网: Monero 是一个安全，隐私和不可追踪的加密货币。通过使用密码学中一种特殊的方法，门罗确保了所有交易保持 100% 的不可关联和不可追溯性(unlinkable and untraceable)。尽管 bytecoin 十分有前景，但是人们也注意到发生了很多负面的事情，并且鉴于它已经产出了 80% 的币。所以，决定将 bytocin 分叉，新链上的币叫做 Bitmonero，最终被重新命名为 Monero（门罗），在世界语（Esperanto）中叫做“coin”，硬币的意思。门罗的出块时间为两分钟。门罗由一个 7 人的开发者团队领导，其中 5 人匿名，另 2 人已公开。他们是 David Latapie 和 Riccardo Spagni aka “Fluffypony”。项目是开源众筹的形式进行。门罗的特别之处门罗采用CrytoNote算法，使得它具有以下几个特性。  你的钱就是你的：你对交易有着绝对的控制权。你为你的钱负责。因为你的身份是私有的（private），没有人能够看到你把钱花到了哪儿。  可替代性：所谓可替换性，指的是一个商品或资产与其他同类型个体商品或资产的互换性。加密货币中理想的可替代性是什么？  以 bitcoin 为例，它引以为豪的一点就是比特币是开放的账本，但是，这也意味着每个人都可以看到里面的每一笔交易，更重要的是，每个人都可以看到交易的踪迹。简单来说，如果你拥有一个曾经用于某个非法交易的比特币，比如购买毒品，那么它的交易细节里面将会永远有这样的印记。实际上，这“污染（taint）”了你的比特币。  在某些比特币服务提供商和交易所中，这些“被污染”的币与“干净的”币永远都不会被一视同仁。这就泯灭了可替换性（fungibility），这也是比特币经常为人所诟病的一点。毕竟，为什么别人做了错事，需要你来买单呢？于是门罗诞生了。由于所有数据和交易都是不公开的，没有人能够知道你的门罗币在之前经历了哪些交易，也无法知道你的门罗币会用来购买什么。  动态扩展性：比特币协议限定了区块大小为 1 Mb（译者注：扩容，BCH 等为后话）。在早期，比特币并没有任何区块大小的限制，但是后来为了防止垃圾交易，就施加了大小限制。门罗并没有任何“预先设定”的限制，系统有一个区块奖励的惩罚（block reward penalty）。工作方式如下：          首先，最后 100 个区块大小的中位数叫做 M100。假设矿工挖出了一个新的块，大小记为 NBS（New Block Size）。如果 NBS &gt; M100，那么区块奖励会随着 NBS 超过 M100 的平方递减。      也就是说，如果 NBS 大于 M100 [10%, 50%, 80%, 100%]，那么区块奖励随之减少 [1%, 25%, 64%, 100%]. 通常来说，区块大小超过 2 倍的 M100 是不被允许的，同时如果区块小于等于 60kb 则会免于任何的区块奖励惩罚。        防 ASIC：门罗不算是严格的“ASIC resistant”，但是制作针对门罗的 ASIC 将会成本高昂，以至于不值得如此操作。当我们说门罗基于 CryptoNote 系统时，已经使得它与比特币截然不同。在基于 CtryptoNote 的系统中所用的哈希算法叫做 “CryptoNight”。          创造 Cryptonight 是为了构建一个更加公平，更加去中心化的货币系统。利用 cryptonight 的加密货币无法用 ASIC 挖矿。它的目的是希望可以杜绝出现矿池的出现，并使得货币分散地更均匀。      Crytponight 需要 2 MB 的快速内存来工作。这意味着并行哈希会被一个芯片可以分配多少内存限制，同时保持尽可能地低成本，以免“入不敷出”。2 MB 的内存要比 SHA256 电路要耗费多得多的硅。      Cryptonight 是 CPU 和 GPU 友好型，因为它利用了 AES-Ni 指令集。基本上，如果你用的是没那么老的机器，由 Cryptonight 所完成的一些工作已经在硬件层完成。      已经有不少说法说，想要把门罗从工作量证明算法切换至“Cuckoo Cycle”（一种不同于工作量证明的哈希）。如果这种切换真的发生，那么在 R&amp;D 门罗 ASIC 友好型所耗费的所有工作都将付之东流。        多密钥：          view key：门罗有一个 public view key 和 private view key。public view key 用于生成一次性的 stealth public address(隐匿的公开地址)，资金将会通过这个地址发送给接收者。private view key 用于接收者扫描区块链来找到发送给他们的资金。      spend key： 如果 view key 大多是为了交易接收方，那么 spend key 就是全部有关于发送方。跟上面一样，有两个 spend key：public spend key 和 private spend key。public spend key 帮助发送方参与环交易（ring transaction），并验证密钥镜像(key image)的签名。private spend key 帮助创建密钥镜像，密钥镜像能够使得他们能够发送交易。      门罗地址是一个 95 个字符的字符串，分别由 public spend key 和 public view key 构成。      加密货币交易的工作方式假设 Alice 需要给 Bob 发送一些比特币，交易看起来是怎样的？交易输入每个币都来源于之前的交易。所以，Alice 可以将之前交易的输出作为新交易的输入。Alice 需要从下列交易从获得输入，比如 TX(0), TX(1) 和 TX(2)。这三笔交易会被一起包含到这笔交易，并有一个交易输出 TX(Input)。交易输出输出就是 Bob 可以在之后交易花费的钱，也可能会出现找零，找零会返回给 Alice。找零会成为 Alice 未来任意交易的输入。有了公钥加密以后，比特币交易才成为可能。为了对它有一个基本的理解，请看下图：比特币用户首先选择私钥，公钥由私钥衍生而来。将公钥进行哈希得到一个公开的地址公布出去。如果 Alice 要给 Bob 发送 BTC，Alice 直接给 Bob 公开的地址发送即可。门罗团队给出的“电子现金三角（Electronic cash triangle）”正如他们所说，一个理想的电子现金应该满足三个前提：电子的、去中心化的、隐私的门罗背后的哲学就是完全隐私和不透明性。发送方隐私由环签名（Ring Signature）实现。  Ring Signatures(环签名)保证了发送方隐私  Condidential Address(隐匿地址)保证了接收方隐私  Ring CT(Ring Confidential Transaction, 环隐匿交易)保证了交易隐私门罗密码学Ring Signatures环签名，简单来说就是交易过程中把几个人签名混合在一起，然后得到一个独一无二的签名，这样就没人知道这个签名是否是你本人的。假设，Alice 发送 1000 XMR(XMR 即门罗币) 给 Bob，系统会如何使用环签名来隐藏她的身份？首先，Alice 会确认她的“ring size（环大小）”。ring size 是取自区块链的随机输出，它等于 Alice 的输出值，即 1000 XMR。ring size 越大，交易越大，继而交易费越高。然后，她用 private spend key 对输出进行签名，并发给到区块链。另一点要注意的是，Alice 不需要向之前交易的所有者发送请求来使用这些输出。假设 Alice 选择的 ring size 为 5 ，也就是说 4 个 decoy output（诱骗输出） 和它自己的交易，从外面看起来就像这样：在一个环签名交易中，任意一个 decoy 就像真实输出一样，因为任何不相关的第三方（包括矿工）都无法知道发送方是谁。防止双花：矿工要做的一个重要的事情就是防止“双花”。双花就是指在同一时间，同一笔钱出现在两笔，甚至更多的交易中。双花被矿工所解决。在一个区块链中，只有当矿工将交易包含在区块并出块，交易才算完成。假设 A 打算给 B 发送一个比特币，然后它发送同样一个币给 C，矿工会把其中一笔交易放到块里，并在处理过程中覆盖另一笔交易，防止双花。但是在门罗中，由于环签名这些都是不可见的。那么要如何防止双花呢？门罗的每一笔交易都有它自己的唯一的密钥镜像（key image），鉴于密钥镜像对于每个交易都是不同的，矿工就可以非常容易地检测，判断是否双花。stealth address门罗的最大一个卖点就是交易的不可关联性（unlinkability）。基本上，如果有人发送给你 200 XMR，应该没有人知道这笔钱是发送给你的。如果 Alice 要给 Bob 发送门罗币，除了 Alice，应该没人任何人知道 Bob 就是这笔钱的接收者。门罗要如何保证 Bob 的隐私？Bob 有两个 public key：public view key 和 public send key。为了推进交易，Alice 的钱包会用 Bob 的 public view key 和 public send key 来生成一次性独一无二的 public key。one-time public key （P） 的计算方式： $ P = H(rA)G + B $其中：  r = Random scalar chosen by Alice. Alice 选取的一个随机的标量  A = Bob’s public view key. Bob 的 public view key  G = Cryptographic constant. 密码学常数  B = Bob’s public spend key. Bob 的 public spend key  H() = The Keccak hashing algorithm used by Monero. 门罗所使用的 Keccak 哈希算法由这种方法生成一次性公钥，然后再生成在区块链里一次性的公开地址，这样的地址就叫做“stealth address”，Alice 就通过它给 Bob 发送门罗币。现在，Bob 要如何从数据的随机分布中解锁收到的门罗币呢?Bob 也有一个 private spend key。private spend key 就是用来帮助 Bob 扫描区块链找到他的相关交易。当 Bob 找到这笔交易，他可以通过一个 private key 取回他的门罗币，这个 private key 与一次性的 public key 相关。因此 Alice 付给 Bob 门罗币，无人知晓。key image计算方式：$I = xH(P)$  x 为发送方的 private spend key  P是one-time public key从 key image “I” 计算出一次性的 public address P 十分困难(这是密码学哈希函数的一个属性，正着算很容易，反推很难)，因此 Alice 的身份永远也不会暴露。当 P 被哈希的时候，永远都会返回同一个值，意味着 H(P) 也总是同一个值。既然 x 的值对于 Alice 来说是个常数，她也就是永远也无法生成多个 I 值。这使得 key image 对于每一笔交易都是不同的。Ring Confidential Transactions基于 Gergory Maxwell 的研究实现了 Ring CT，Ring CT保证了交易本身的匿名性，它在链上隐藏了交易的数额。这也意味着所有的交易输入都不需要再被拆分为已知的面额，钱包现在可以从任意的 Ring CT 输出中选择 ring 成员。环形加密技术的基础仍旧是与比特币一样的基于Hash值的公钥+私钥加解机制。只是比特币是用接受者的公钥加密，接受者用与之配对的私钥解密验证。而环形加密则使用了多个公钥进行加密，并用接受者的私钥进行解密验证。Kovri and I2PI2P 是一个路由系统，它能够让应用秘密地互相发送信息而无须任何外部干涉。Kovri 是 I2P 的 C++ 实现，它也会被集成到门罗里面。Kovri 将会隐藏你的网络流量，如此一来，被动的网络监控就根本不会暴露你正在使用门罗。为此，你的所有门罗流量将会被加密并通过 I2P 节点路由。节点就像瞎的看门人，它们会知道你的信息通过，但是不知道这些去向哪儿以及信息的具体内容。门罗价值和市值目前，XMR流通市值$1,522,148,966，流通量16,335,709 XMR每个XMR￥637，占全球总市场0.7%，排名10。门罗总量为 1840 万，挖矿奖励会持续到 2022 年 5 月 31。之后，系统设定为 0.3 XMR/min 的奖励。这是为了矿工能过持续的激励挖矿，而不仅仅依赖于交易费，毕竟门罗已经被挖完了。门罗的优势与劣势优势  隐私性最好的几个加密货币之一  交易之间不可联系  交易不可跟踪  区块链没有区块限制，并且可动态扩展  即使当门罗的供应耗尽，也会有 0.3 XMR/min 的供应量激励矿工  经济上已经获得了巨大增长  其透明性实可选的。如果有人想要交易对某些人可见，比如给审计人员查看密钥。这也使得门罗是可审计的加密货币。  有一个非常有能力的强大开发团队领导工作劣势  尽管门罗已经被设计为防 ASIC 来避免中心化，但是门罗接近 43% 的算力仍然为 3 个矿池所有：  比起其他加密货币，由于涉及了很多的加密操作，门罗的交易大小要大得多。  门罗的钱包兼容性不强。事实上，门罗至今没有硬件钱包（截止成文之时）。  入门有难度，并且尚未被广泛接纳。  因为它并非是基于比特币的货币，门罗面临的问题是向其中加入一些元素相对更困难。毫无疑问，未来会更加开放和去中心化，门罗也会因其隐私性而越具吸引力。特别有趣之处在于，它是少数几个不是基于比特币的币，却是同时有着真正价值的“潜力股”。对门罗来说，随着它已经经历了惊人的增长，未来依旧光明一片。当实现 Kovri 以后，相信一切会变得更加有趣.注：cryptonote系统、monero]]></content>
      <categories>
        
          <category> 区块链 </category>
        
      </categories>
      <tags>
        
          <tag> XMR </tag>
        
          <tag> 门罗币 </tag>
        
          <tag> 区块链 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Sorket😇]]></title>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2018/08/22/socket/</url>
      <content type="text"><![CDATA[I/O模型一个输入操作通常包括两个阶段：  等待数据准备好  从内核向进程复制数据对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。Unix 下有五种 I/O 模型：  阻塞式 I/O  非阻塞式 I/O  I/O 复用（select 和 poll）  信号驱动式 I/O（SIGIO）  异步 I/O（AIO）阻塞式 I/O应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回。应该注意到，在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他程序还可以执行，因此不消耗 CPU 时间，这种模型的执行效率会比较高。下图中，recvfrom 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);非阻塞式 I/O应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。由于 CPU 要处理更多的系统调用，因此这种模型是比较低效的。I/O 复用使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞，当某一个套接字可读时返回。之后再使用 recvfrom 把数据从内核复制到进程中。它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。并且相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。信号驱动 I/O应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。异步 I/O进行 aio_read 系统调用会立即返回，应用进程继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。同步 I/O 与异步 I/O  同步 I/O：应用进程在调用 recvfrom 操作时会阻塞。  异步 I/O：不会阻塞。阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，虽然非阻塞式 I/O 和信号驱动 I/O 在等待数据阶段不会阻塞，但是在之后的将数据从内核复制到应用进程这个操作会阻塞。五大 I/O 模型比较前四种 I/O 模型的主要区别在于第一个阶段，而第二个阶段是一样的：将数据从内核复制到应用进程过程中，应用进程会被阻塞。I/O 复用select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。selectint select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义。timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。pollint poll(struct pollfd *fds, unsigned int nfds, int timeout);pollfd 使用链表实现。比较功能select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。  select 会修改描述符，而 poll 不会；  select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 的描述符类型使用链表实现，没有描述符的数量的限制；  poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。  如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。速度select 和 poll 速度都比较慢。  select 和 poll 每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。  select 和 poll 的返回结果中没有声明哪些描述符已经准备好，所以如果返回值大于 0 时，应用进程都需要使用轮询的方式来找到 I/O 完成的描述符。可移植性几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。epollint epoll_create(int size);int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。epoll 仅适用于 Linux OS。epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。工作模式epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。LT 模式当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。ET 模式和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。应用场景很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。select 应用场景select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时要求更高的场景，比如核反应堆的控制。select 可移植性更好，几乎被所有主流平台所支持。poll 应用场景poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且epoll 的描述符存储在内核，不容易调试。epoll 应用场景只需要运行在 Linux 平台上，并且有非常大量的描述符需要同时轮询，而且这些连接最好是长连接。  来源：Sorket]]></content>
      <categories>
        
          <category> 计算机基础 </category>
        
      </categories>
      <tags>
        
          <tag> Sorket </tag>
        
          <tag> 计算机网络 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[互联网协议入门😇]]></title>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2018/08/22/IPS/</url>
      <content type="text"><![CDATA[互联网的核心是一系列协议，总称为”互联网协议”（Internet Protocol Suite）。它们对电脑如何连接和组网，做出了详尽的规定。理解了这些协议，就理解了互联网的原理。概述五层模型互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。用户接触到的，只是最上面的一层，根本没有感觉到下面的层。要理解互联网，必须从最下层开始，自下而上理解每一层的功能。如何分层有不同的模型，有的模型分七层，有的分四层。我觉得，把互联网分成五层，比较容易解释。如上图所示，最底下的一层叫做”实体层”（Physical Layer），最上面的一层叫做”应用层”（Application Layer），中间的三层（自下而上）分别是”链接层”（Link Layer）、”网络层”（Network Layer）和”传输层”（Transport Layer）。越下面的层，越靠近硬件；越上面的层，越靠近用户。层与协议每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。大家都遵守的规则，就叫做”协议”（protocol）。互联网的每一层，都定义了很多协议。这些协议的总称，就叫做”互联网协议”（Internet Protocol Suite）。它们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。实体层(物理层)电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。这就叫做”实体层”，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。链接层定义单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？这就是”链接层”的功能，它在”实体层”的上方，确定了0和1的分组方式。以太网协议早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做”以太网”（Ethernet）的协议，占据了主导地位。以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。“标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。“标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。MAC地址上面提到，以太网数据包的”标头”，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？以太网规定，连入网络的所有设备，都必须具有“网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。广播定义地址只是第一步，后面还有更多的步骤。首先，一块网卡怎么会知道另一块网卡的MAC地址？回答是有一种ARP协议，可以解决这个问题。以太网数据包必须知道接收方的MAC地址，然后才能发送。其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？回答是以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的”标头”，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”广播”（broadcasting）。有了数据包的定义、网卡的MAC地址、广播的发送方式，”链接层”就可以在多台计算机之间传送数据了。网络层网络层的由来以太网协议，依靠MAC地址发送数据。理论上，单单依靠MAC地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。但是，这样做有一个重大的缺点。以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。（”路由”的意思，就是指如何向不同的子网络分发数据包）遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。于是，”网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。IP协议规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数“子网掩码”（subnet mask）。所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。IP数据包根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。但是前面说过，以太网数据包只包含MAC地址，并没有IP地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？回答是不需要，我们可以把IP数据包直接放进以太网数据包的”数据”部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。具体来说，IP数据包也分为”标头”和”数据”两个部分。“标头”部分主要包括版本、长度、IP地址等信息，”数据”部分则是IP数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样。ARP协议因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。所以，我们需要一种机制，能够从IP地址得到MAC地址。这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。传输层传输层的由来有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。“端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。“传输层”的功能，就是建立“端口到端口”的通信。相比之下，”网络层”的功能是建立“主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做”套接字”（socket）。有了它，就可以进行网络应用程序开发了。UDP协议现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。UDP数据包，也是由”标头”和”数据”两部分组成。“标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的“数据”部分，而前面说过，IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样：UDP数据包非常简单，”标头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。TCP协议UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。TCP数据包和UDP数据包一样，都是内嵌在IP数据包的”数据”部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。应用层应用程序收到”传输层”的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。“应用层”的作用，就是规定应用程序的数据格式。举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。这是最高的一层，直接面对用户。它的数据就放在TCP数据包的”数据”部分。因此，现在的以太网的数据包就变成下面这样。  来源：互联网入门协议]]></content>
      <categories>
        
          <category> 计算机基础 </category>
        
      </categories>
      <tags>
        
          <tag> TCP/IP </tag>
        
          <tag> 计算机网络 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Next主题超深度优化]]></title>
      <url>/%E6%8A%80%E6%9C%AF/2018/08/18/next-theme/</url>
      <content type="text"><![CDATA[  设置next-Pisces主题透明度  Jekyll建站过程  Hexo+Next主题优化  打造个人炫酷Next博客  添加日历插件]]></content>
      <categories>
        
          <category> 技术 </category>
        
      </categories>
      <tags>
        
          <tag> Next </tag>
        
          <tag> Jekyll </tag>
        
          <tag> 教程 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[各种云产品介绍]]></title>
      <url>/%E4%BA%91%E4%BA%A7%E5%93%81/2018/08/11/introduce-aliyun-products/</url>
      <content type="text"><![CDATA[先留下一个链接防丢失：最新最全的阿里云产品手册出炉  ，产品手册共三册，有点多，留着之后慢慢看，不过我觉得看官方帮助文档已经足够了，看文档累就看看视频阿里云大学。今天就先大概了解一下阿里云各种云产品及其服务，之后再详细介绍各种云产品的作用以及适用场景。  参考：了解各种阿里云产品都是干嘛的网站架构演变步骤  开始就一台应用服务器 —&gt; ECS；  需要把数据库独立出来 —&gt; RDS；  需要给数据库加缓存 —&gt; OCS；  加机器需要负载均衡 —&gt; SLB；  数据库需要分库分表 —&gt; DRDS；  需要独立的分布式存储 —&gt; OSS；  需要针对互联网场景的结构化存储 —&gt; OTS；  需要内容分发网络来提升体验和节省成本 —&gt; CDN；  需要搜索服务来提供站内和站外的信息检索 —&gt; Open Search；  需要消息队列来异步化处理请求 —&gt; MQS；  需要大规模数据处理 —&gt; ODPS；  需要对应用和服务进行全面测试 —&gt; PTS.  ······ECS (Elastic Compute Service)：以虚拟机的方式将一台物理机分成多台云服务器，提供可伸缩的计算服务。SLB (Server Load Balance）：基于LVS和Tengine实现的4层和7层负载均衡，有动态扩容，session保持等特点。RDS (Relational Database Service)：通过云服务的方式让关系型数据库管理、操作和扩展变得更加简单。OCS (Open Cache Service)：基于内部Tair，增加一层Proxy，支持海量小数据的高速访问。OTS（Open Table Service）：海量（结构化）数据存储和实时查询服务。OSS（Open Store Service）：对任意大小数据对象提供高可用，高可靠的海量存储服务。CDN（Content Delevery Network）：通过覆盖全网的缓存服务以及负载均衡等技术将用户请求定向到最合适的区域，提高用户服务的响应速度及网站服务能力。OAS (Open Archive Service)：离线归档，冷数据备份，类似Amazon Glacier。ODPS（Open Data Processing Service）：海量数据处理和分析平台。SLS (Simple Log Service)：解决异构、分布式系统中日志实时收集、存储与查询的基础服务。阿里四大件我们常说的阿里云四大件，即云服务器ECS，云数据库RDS，负载均衡SLB和对象存储OSS。ECS云服务器ECS以虚拟机的方式将一台物理机分成多台云服务器，提供可伸缩的计算服务，是最基本的云服务产品，这是每个用户最先接触的云产品，ECS从1核1G到32核64G，之后估计还有更高配置的，用户购买后还可以升降其配置，一般个人或者一些小公司，一台ECS就够用了，大企业会从安全，性能，加载速度等方面进行考虑，可能还需要购买其他产品。ECS衍生出很多类型的云服务器，例如适合初级用户的轻量级服务器，迎合高性能场景的云服务器诸如GPU云服务器、FPGA云服务器、神龙云服务器等等，这些都是企业云的基本款。RDS云数据库RDS，通过云服务的方式让关系型数据库管理、操作和扩展变得更加简单。 ，像MySQL，PostgreSQL，SQL Server，MongoDB，Memcache(Redis)等阿里云都有提供。一般的，用户在ECS上面可以自己搭建数据库，不需要RDS，但是企业由于自身业务发展需求，需要将数据库独立出来，方便管理。SLB负载均衡SLB，基于LVS和Tengine实现的4层和7层负载均衡，有动态扩容，session保持等特点。 ，即对多台ECS进行流量分发服务，为了应对业务需求，企业往往会有多台ECS提供服务器，SLB就是将用户的请求按照企业自定义的策略转发到最优的服务器。OSS对象存储OSS，基本上相当于一个云空间，可以通过url直接访问的。企业一般会将一些静态文件（视频，图片，文档等大文件）从ECS中独立出来，放到OSS中。其他云计算产品CDN内容分发网络，通过覆盖全网的缓存服务以及负载均衡等技术将用户请求定向到最合适的区域，提高用户服务的响应速度及网站服务能力。 假设企业的ESC在杭州，那么位于东北地区的用户访问速度就比较慢，CDN可以解决这个问题，CDN将源站点内容分发到最接近用户的节点，使用户可就近取得所需内容，提高用户访问的相应速度和成功率。VPC专有网络VPC可以帮助企业在阿里云构建一个隔离的网络环境，用户可以自定义IP地址、网段、路由表和网关等，VPC可以提供更安全灵活的网络环境，为用户构建混合云提供服务。（注：云服务分公有云，私有云和混合云等）弹性伸缩传统的企业自建的私有机房是不具有弹性伸缩功能的，假设企业遇到业务波峰，只能通过人为的升级硬件来应对，业务回落时就会造成硬件资源的浪费，而弹性伸缩很好的解决了这个痛点。阿里云弹性伸缩可以管理您的集群，在高峰期自动增加ECS实例，在业务回落时自动减少ECS实例，节省基础设施成本。另外，这个弹性伸缩是免费的。安全系列产品DDoS高防IPDDoS是目前比较常见的攻击方式，为了抵御DDoS攻击，用户可以通过配置高防IP，将攻击流量引流到高防IP，确保源站的稳定可靠。讲真，阿里云的DDoS高防IP还挺贵的。安骑士安骑士一款主机安全软件，为您提供主机漏洞检测、基线检查、病毒查杀、资产统一管理等功能，为您建立安全运维管理平台。安骑士企业版可以免费试用7天，之后想再使用，是需要付费的。SSL证书这个就是我之前提到的SSL证书以及https协议，https协议是需要SSL证书的，就是我们在访问网站是左边绿色的那个，没有SSL证书就会显示红色的警告，htttps为网站访问提供了一层加密服务，更加安全。我们可以通过向阿里云申请签发SSL证书1，目前免费的有Symantec赛门铁克品牌的SSL，一年期限。态势感知态势感知，有点类似于先知的意思 。态势感知会收集企业20种原始日志和网络空间威胁情报，利用机器学习还原已发生的攻击，并预测未发生的攻击，帮客户扩大安全可见性，并集中管理云上资产安全事件。堡垒机企业往往更加关注外部的安全威胁而忽略了企业内部，实际上运维人员误操作或者仿冒运维人员将对企业造成很严重的损失，更有甚至是致命的。例如：携程的宕机12小时事件，由于员工错误操作，删除了服务器代码，据不完全统计，携程宕机带来的直接损失就是每小时160万美金。堡垒机基于协议正向代理实现对SSH、Windows远程桌面、SFTP等常见运维协议的 数据流进行全程记录，再通过协议数据流重组的方式进行录像回放，达到运维审计的目的。网络中间件相关消息队列MQS消息队列，最典型的应用场景就是一年一度的双十一购物节，消息队列是一个真正具备低延迟、高并发、高可用、高可靠，可支撑万亿级数据洪峰的分布式消息中间件。当小仙女们开启大规模的剁手模式时，用户大量并发访问商品数据库，消息队列可以缓解瓶颈，减少页面响应时间，当然还有其他方面的功能优势，咱这里阿里云百科网就不过多赘述，双十一就是MQ的典型应用场景，大概就是这么个意思。万网产品  域名：有未注册域名和已过期的注册域名以及二手域名，一般用户就直接选用未注册域名就行了，除特别需求，重要域名被其他公司抢注，这就比较难搞了。。。  虚拟主机：适合新手建站，无需自己配置web环境，简单易管理，价格便宜。  企业邮箱：基本上可以用已经注册的企业域名作为企业邮箱域名，邮箱系统可以由企业自建，不过现在阿里云、腾讯云、网易等都有提供免费版的企业邮箱 。  云解析DNS：这个也有免费的，你在阿里云购买了域名，就提供免费的域名解析，当然还有付费版的DNS，各方面性能自然好一点。]]></content>
      <categories>
        
          <category> 云产品 </category>
        
      </categories>
      <tags>
        
          <tag> 阿里云 </tag>
        
          <tag> 网站建设 </tag>
        
          <tag> 云服务器 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[有趣的注释]]></title>
      <url>/%E5%A8%B1%E4%B9%90/2018/06/25/entertainmen/</url>
      <content type="text"><![CDATA[  非常有趣，哈哈哈哈哈/***　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 *　　　　　　　　　瓦瓦　　　　　　　　　　　　十　　　　　　　　　　　　　 *　　　　　　　　十齱龠己　　　　　　　　　亅瓦車己　　　　　　　　　　　　 *　　　　　　　　乙龍龠毋日丶　　　　　　丶乙己毋毋丶　　　　　　　　　　　 *　　　　　　　　十龠馬鬼車瓦　　　　　　己十瓦毋毋　　　　　　　　　　　　 *　　　　　　　　　鬼馬龠馬龠十　　　　己己毋車毋瓦　　　　　　　　　　　　 *　　　　　　　　　毋龠龠龍龠鬼乙丶丶乙車乙毋鬼車己　　　　　　　　　　　　 *　　　　　　　　　乙龠龍龍鬼龍瓦　十瓦毋乙瓦龠瓦亅　　　　　　　　　　　　 *　　　　　　　　　　馬齱龍馬鬼十丶日己己己毋車乙丶　　　　　　　　　　　　 *　　　　　　　　　　己齱馬鬼車十十毋日乙己己乙乙　　　　　　　　　　　　　 *　　　　　　　　　　　車馬齱齱日乙毋瓦己乙瓦日亅　　　　　　　　　　　　　 *　　　　　　　　　　　亅車齺龖瓦乙車龖龍乙乙十　　　　　　　　　　　　　　 *　　　　　　　　　　　　日龠龠十亅車龍毋十十　　　　　　　　　　　　　　　 *　　　　　　　　　　　　日毋己亅　己己十亅亅　　　　　　　　　　　　　　　 *　　　　　　　　　　　丶己十十乙　　丶丶丶丶丶　　　　　　　　　　　　　　 *　　　　　　　　　　　亅己十龍龖瓦　　丶　丶　乙十　　　　　　　　　　　　 *　　　　　　　　　　　亅己十龠龖毋　丶丶　　丶己鬼鬼瓦亅　　　　　　　　　 *　　　　　　　　　　　十日十十日亅丶亅丶　丶十日毋鬼馬馬車乙　　　　　　　 *　　　　　　　　　　　十日乙十亅亅亅丶　　十乙己毋鬼鬼鬼龍齺馬乙　　　　　 *　　　　　　　　　　　丶瓦己乙十十亅丶亅乙乙乙己毋鬼鬼鬼龍齱齺齺鬼十　　　 *　　　　　　　　　　　　乙乙十十十亅乙瓦瓦己日瓦毋鬼鬼龠齱齱龍龍齱齱毋丶　 *　　　　　　　　　　　　亅十十十十乙瓦車毋瓦瓦日車馬龠龍龍龍龍龍龠龠龠馬亅 *　　　　　　　　　　　　　十十十十己毋車瓦瓦瓦瓦鬼馬龠龍龠龠龍龠龠龠馬龠車 *　　　　　　　　　　　　　　亅十十日毋瓦日日瓦鬼鬼鬼龠龠馬馬龠龍龍龠馬馬車 *　　　　　　　　　　　　　　亅亅亅乙瓦瓦毋車車車馬龍龠鬼鬼馬龠龍龍龠馬馬鬼 *　　　　　　　　　　　　丶丶乙亅亅乙車鬼鬼鬼毋車龍龍龠鬼馬馬龠龍齱齱龍馬鬼 *　　　　　　　　　　　亅己十十己十日鬼鬼車瓦毋龠龍龠馬馬龠龠龠齱齺齺齱龠鬼 *　　　　　　　　　　　　亅乙乙乙十車馬車毋馬齱齱龍龠龠龠馬龠龍齱龍龠龠鬼瓦 *　　　　　　　　　　　　　　　　丶毋龠鬼車瓦車馬龠龍龠龠龍齱齱龠馬馬鬼毋日 *　　　　　　　　　　　　　　　　十乙己日十　　丶己鬼龍齱齺齱龍馬馬馬車毋己 *　　　　　　　　　　　　　　丶十己乙亅丶　　　　　　亅瓦馬龠龍龠龠馬毋瓦乙 *　　　　　　　　　　　　　丶十十乙亅十　　　　　　　　亅己瓦車馬龠鬼車瓦乙 *　　　　　　　　　　　　　丶十乙十十丶　　　　　　　　　丶丶亅十瓦鬼車瓦己 *　　　　　　　　　　　　　　丶亅亅丶　　　　　　　　　　　　　　　亅日瓦日 *　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　丶 *//***                                                                           *          .,:,,,                                        .::,,,::.           *        .::::,,;;,                                  .,;;:,,....:i:          *        :i,.::::,;i:.      ....,,:::::::::,....   .;i:,.  ......;i.         *        :;..:::;::::i;,,:::;:,,,,,,,,,,..,.,,:::iri:. .,:irsr:,.;i.         *        ;;..,::::;;;;ri,,,.                    ..,,:;s1s1ssrr;,.;r,         *        :;. ,::;ii;:,     . ...................     .;iirri;;;,,;i,         *        ,i. .;ri:.   ... ............................  .,,:;:,,,;i:         *        :s,.;r:... ....................................... .::;::s;         *        ,1r::. .............,,,.,,:,,........................,;iir;         *        ,s;...........     ..::.,;:,,.          ...............,;1s         *       :i,..,.              .,:,,::,.          .......... .......;1,        *      ir,....:rrssr;:,       ,,.,::.     .r5S9989398G95hr;. ....,.:s,       *     ;r,..,s9855513XHAG3i   .,,,,,,,.  ,S931,.,,.;s;s&amp;BHHA8s.,..,..:r:      *    :r;..rGGh,  :SAG;;G@BS:.,,,,,,,,,.r83:      hHH1sXMBHHHM3..,,,,.ir.     *   ,si,.1GS,   sBMAAX&amp;MBMB5,,,,,,:,,.:&amp;8       3@HXHBMBHBBH#X,.,,,,,,rr     *   ;1:,,SH:   .A@&amp;&amp;B#&amp;8H#BS,,,,,,,,,.,5XS,     3@MHABM&amp;59M#As..,,,,:,is,    *  .rr,,,;9&amp;1   hBHHBB&amp;8AMGr,,,,,,,,,,,:h&amp;&amp;9s;   r9&amp;BMHBHMB9:  . .,,,,;ri.   *  :1:....:5&amp;XSi;r8BMBHHA9r:,......,,,,:ii19GG88899XHHH&amp;GSr.      ...,:rs.   *  ;s.     .:sS8G8GG889hi.        ....,,:;:,.:irssrriii:,.        ...,,i1,   *  ;1,         ..,....,,isssi;,        .,,.                      ....,.i1,   *  ;h:               i9HHBMBBHAX9:         .                     ...,,,rs,   *  ,1i..            :A#MBBBBMHB##s                             ....,,,;si.   *  .r1,..        ,..;3BMBBBHBB#Bh.     ..                    ....,,,,,i1;    *   :h;..       .,..;,1XBMMMMBXs,.,, .. :: ,.               ....,,,,,,ss.    *    ih: ..    .;;;, ;;:s58A3i,..    ,. ,.:,,.             ...,,,,,:,s1,     *    .s1,....   .,;sh,  ,iSAXs;.    ,.  ,,.i85            ...,,,,,,:i1;      *     .rh: ...     rXG9XBBM#M#MHAX3hss13&amp;&amp;HHXr         .....,,,,,,,ih;       *      .s5: .....    i598X&amp;&amp;A&amp;AAAAAA&amp;XG851r:       ........,,,,:,,sh;        *      . ihr, ...  .         ..                    ........,,,,,;11:.        *         ,s1i. ...  ..,,,..,,,.,,.,,.,..       ........,,.,,.;s5i.          *          .:s1r,......................       ..............;shs,            *          . .:shr:.  ....                 ..............,ishs.              *              .,issr;,... ...........................,is1s;.                *                 .,is1si;:,....................,:;ir1sr;,                   *                    ..:isssssrrii;::::::;;iirsssssr;:..                     *                         .,::iiirsssssssssrri;;:.                       */						 /*** *               ii.                                         ;9ABH,           *              SA391,                                    .r9GG35&amp;G           *              &amp;#ii13Gh;                               i3X31i;:,rB1          *              iMs,:,i5895,                         .5G91:,:;:s1:8A          *               33::::,,;5G5,                     ,58Si,,:::,sHX;iH1         *                Sr.,:;rs13BBX35hh11511h5Shhh5S3GAXS:.,,::,,1AG3i,GG         *                .G51S511sr;;iiiishS8G89Shsrrsh59S;.,,,,,..5A85Si,h8         *               :SB9s:,............................,,,.,,,SASh53h,1G.        *            .r18S;..,,,,,,,,,,,,,,,,,,,,,,,,,,,,,....,,.1H315199,rX,        *          ;S89s,..,,,,,,,,,,,,,,,,,,,,,,,....,,.......,,,;r1ShS8,;Xi        *        i55s:.........,,,,,,,,,,,,,,,,.,,,......,.....,,....r9&amp;5.:X1        *       59;.....,.     .,,,,,,,,,,,...        .............,..:1;.:&amp;s        *      s8,..;53S5S3s.   .,,,,,,,.,..      i15S5h1:.........,,,..,,:99        *      93.:39s:rSGB@A;  ..,,,,.....    .SG3hhh9G&amp;BGi..,,,,,,,,,,,,.,83       *      G5.G8  9#@@@@@X. .,,,,,,.....  iA9,.S&amp;B###@@Mr...,,,,,,,,..,.;Xh      *      Gs.X8 S@@@@@@@B:..,,,,,,,,,,. rA1 ,A@@@@@@@@@H:........,,,,,,.iX:     *     ;9. ,8A#@@@@@@#5,.,,,,,,,,,... 9A. 8@@@@@@@@@@M;    ....,,,,,,,,S8     *     X3    iS8XAHH8s.,,,,,,,,,,...,..58hH@@@@@@@@@Hs       ...,,,,,,,:Gs    *    r8,        ,,,...,,,,,,,,,,.....  ,h8XABMMHX3r.          .,,,,,,,.rX:   *   :9, .    .:,..,:;;;::,.,,,,,..          .,,.               ..,,,,,,.59   *  .Si      ,:.i8HBMMMMMB&amp;5,....                    .            .,,,,,.sMr *  SS       :: h@@@@@@@@@@#; .                     ...  .         ..,,,,iM5 *  91  .    ;:.,1&amp;@@@@@@MXs.                            .          .,,:,:&amp;S *  hS ....  .:;,,,i3MMS1;..,..... .  .     ...                     ..,:,.99 *  ,8; ..... .,:,..,8Ms:;,,,...                                     .,::.83 *   s&amp;: ....  .sS553B@@HX3s;,.    .,;13h.                            .:::&amp;1 *    SXr  .  ...;s3G99XA&amp;X88Shss11155hi.                             ,;:h&amp;, *     iH8:  . ..   ,;iiii;,::,,,,,.                                 .;irHA   *      ,8X5;   .     .......                                       ,;iihS8Gi *         1831,                                                 .,;irrrrrs&amp;@ *           ;5A8r.                                            .:;iiiiirrss1H *             :X@H3s.......                                .,:;iii;iiiiirsrh *              r#h:;,...,,.. .,,:;;;;;:::,...              .:;;;;;;iiiirrss1 *             ,M8 ..,....,.....,,::::::,,...         .     .,;;;iiiiiirss11h *             8B;.,,,,,,,.,.....          .           ..   .:;;;;iirrsss111h *            i@5,:::,,,,,,,,.... .                   . .:::;;;;;irrrss111111 *            9Bi,:,,,,......                        ..r91;;;;;iirrsss1ss1111 *//***                                                                     *            .,,       .,:;;iiiiiiiii;;:,,.     .,,                    *          rGB##HS,.;iirrrrriiiiiiiiiirrrrri;,s&amp;##MAS,                 *         r5s;:r3AH5iiiii;;;;;;;;;;;;;;;;iiirXHGSsiih1,                *            .;i;;s91;;;;;;::::::::::::;;;;iS5;;;ii:                   *          :rsriii;;r::::::::::::::::::::::;;,;;iiirsi,                *       .,iri;;::::;;;;;;::,,,,,,,,,,,,,..,,;;;;;;;;iiri,,.            *    ,9BM&amp;,            .,:;;:,,,,,,,,,,,hXA8:            ..,,,.        *   ,;&amp;@@#r:;;;;;::::,,.   ,r,,,,,,,,,,iA@@@s,,:::;;;::,,.   .;.       *    :ih1iii;;;;;::::;;;;;;;:,,,,,,,,,,;i55r;;;;;;;;;iiirrrr,..        *   .ir;;iiiiiiiiii;;;;::::::,,,,,,,:::::,,:;;;iiiiiiiiiiiiri          *   iriiiiiiiiiiiiiiii;;;::::::::::::::::;;;iiiiiiiiiiiiiiiir;         *  ,riii;;;;;;;;;;;;;:::::::::::::::::::::::;;;;;;;;;;;;;;iiir.        *  iri;;;::::,,,,,,,,,,:::::::::::::::::::::::::,::,,::::;;iir:        * .rii;;::::,,,,,,,,,,,,:::::::::::::::::,,,,,,,,,,,,,::::;;iri        * ,rii;;;::,,,,,,,,,,,,,:::::::::::,:::::,,,,,,,,,,,,,:::;;;iir.       * ,rii;;i::,,,,,,,,,,,,,:::::::::::::::::,,,,,,,,,,,,,,::i;;iir.       * ,rii;;r::,,,,,,,,,,,,,:,:::::,:,:::::::,,,,,,,,,,,,,::;r;;iir.       * .rii;;rr,:,,,,,,,,,,,,,,:::::::::::::::,,,,,,,,,,,,,:,si;;iri        *  ;rii;:1i,,,,,,,,,,,,,,,,,,:::::::::,,,,,,,,,,,,,,,:,ss:;iir:        *  .rii;;;5r,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,sh:;;iri         *   ;rii;:;51,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.:hh:;;iir,         *    irii;::hSr,.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.,sSs:;;iir:          *     irii;;:iSSs:.,,,,,,,,,,,,,,,,,,,,,,,,,,,..:135;:;;iir:           *      ;rii;;:,r535r:...,,,,,,,,,,,,,,,,,,..,;sS35i,;;iirr:            *       :rrii;;:,;1S3Shs;:,............,:is533Ss:,;;;iiri,             *        .;rrii;;;:,;rhS393S55hh11hh5S3393Shr:,:;;;iirr:               *          .;rriii;;;::,:;is1h555555h1si;:,::;;;iirri:.                *            .:irrrii;;;;;:::,,,,,,,,:::;;;;iiirrr;,                   *               .:irrrriiiiii;;;;;;;;iiiiiirrrr;,.                     *                  .,:;iirrrrrrrrrrrrrrrrri;:.                         *                        ..,:::;;;;:::,,.                              */                                                                     /*** * ┌───┐   ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐ * │Esc│   │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│  ┌┐    ┌┐    ┌┐ * └───┘   └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘  └┘    └┘    └┘ * ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐ * │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│&amp; 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │N L│ / │ * │ - │ * ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤ * │ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │{ [│} ]│ | \ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │   │ * ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │ * │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│" '│ Enter  │               │ 4 │ 5 │ 6 │   │ * ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤     ┌───┐     ├───┼───┼───┼───┤ * │ Shift  │ Z │ X │ C │ V │ B │ N │ M │&lt; ,│&gt; .│? /│  Shift   │     │ ↑ │     │ 1 │ 2 │ 3 │   │ * ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││ * │ Ctrl│    │Alt │         Space         │ Alt│    │    │Ctrl│ │ ← │ ↓ │ → │ │   0   │ . │←─┘│ * └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘ *//*** *                    _ooOoo_ *                   o8888888o *                   88" . "88 *                   (| -_- |) *                    O\ = /O *                ____/`---'\____ *              .   ' \\| |// `. *               / \\||| : |||// \ *             / _||||| -:- |||||- \ *               | | \\\ - /// | | *             | \_| ''\---/'' | | *              \ .-\__ `-` ___/-. / *           ___`. .' /--.--\ `. . __ *        ."" '&lt; `.___\_&lt;|&gt;_/___.' &gt;'"". *       | | : `- \`.;`\ _ /`;.`/ - ` : | | *         \ \ `-. \_ __\ /__ _/ .-` / / * ======`-.____`-.___\_____/___.-`____.-'====== *                    `=---=' * * ............................................. *          佛祖保佑             永无BUG *//*** *  佛曰: *          写字楼里写字间，写字间里程序员； *          程序人员写程序，又拿程序换酒钱。 *          酒醒只在网上坐，酒醉还来网下眠； *          酒醉酒醒日复日，网上网下年复年。 *          但愿老死电脑间，不愿鞠躬老板前； *          奔驰宝马贵者趣，公交自行程序员。 *          别人笑我忒疯癫，我笑自己命太贱； *          不见满街漂亮妹，哪个归得程序员？ *//*** * _ooOoo_ * o8888888o * 88" . "88 * (| -_- |) *  O\ = /O * ___/`---'\____ * .   ' \\| |// `. * / \\||| : |||// \ * / _||||| -:- |||||- \ * | | \\\ - /// | | * | \_| ''\---/'' | | * \ .-\__ `-` ___/-. / * ___`. .' /--.--\ `. . __ * ."" '&lt; `.___\_&lt;|&gt;_/___.' &gt;'"". * | | : `- \`.;`\ _ /`;.`/ - ` : | | * \ \ `-. \_ __\ /__ _/ .-` / / * ======`-.____`-.___\_____/___.-`____.-'====== * `=---=' *          ............................................. *           佛曰：bug泛滥，我已瘫痪！ *//*** * *   █████▒█    ██  ▄████▄   ██ ▄█▀       ██████╗ ██╗   ██╗ ██████╗ * ▓██   ▒ ██  ▓██▒▒██▀ ▀█   ██▄█▒        ██╔══██╗██║   ██║██╔════╝ * ▒████ ░▓██  ▒██░▒▓█    ▄ ▓███▄░        ██████╔╝██║   ██║██║  ███╗ * ░▓█▒  ░▓▓█  ░██░▒▓▓▄ ▄██▒▓██ █▄        ██╔══██╗██║   ██║██║   ██║ * ░▒█░   ▒▒█████▓ ▒ ▓███▀ ░▒██▒ █▄       ██████╔╝╚██████╔╝╚██████╔╝ *  ▒ ░   ░▒▓▒ ▒ ▒ ░ ░▒ ▒  ░▒ ▒▒ ▓▒       ╚═════╝  ╚═════╝  ╚═════╝ *  ░     ░░▒░ ░ ░   ░  ▒   ░ ░▒ ▒░ *  ░ ░    ░░░ ░ ░ ░        ░ ░░ ░ *           ░     ░ ░      ░  ░ *//*** *                    .::::. *                  .::::::::. *                 :::::::::::  FUCK YOU *             ..:::::::::::' *           '::::::::::::' *             .:::::::::: *        '::::::::::::::.. *             ..::::::::::::. *           ``:::::::::::::::: *            ::::``:::::::::'        .:::. *           ::::'   ':::::'       .::::::::. *         .::::'      ::::     .:::::::'::::. *        .:::'       :::::  .:::::::::' ':::::. *       .::'        :::::.:::::::::'      ':::::. *      .::'         ::::::::::::::'         ``::::. *  ...:::           ::::::::::::'              ``::. * ```` ':.          ':::::::::'                  ::::.. *                    '.:::::'                    ':'````.. *//*** *      ┌─┐       ┌─┐ *   ┌──┘ ┴───────┘ ┴──┐ *   │                 │ *   │       ───       │ *   │  ─┬┘       └┬─  │ *   │                 │ *   │       ─┴─       │ *   │                 │ *   └───┐         ┌───┘ *       │         │ *       │         │ *       │         │ *       │         └──────────────┐ *       │                        │ *       │                        ├─┐ *       │                        ┌─┘ *       │                        │ *       └─┐  ┐  ┌───────┬──┐  ┌──┘ *         │ ─┤ ─┤       │ ─┤ ─┤ *         └──┴──┘       └──┴──┘ *                神兽保佑 *               代码无BUG! *//*** *      ┌─┐       ┌─┐ *   ┌──┘ ┴───────┘ ┴──┐ *   │                 │ *   │       ───       │ *   │   &gt;        &lt;    │ *   │                 │ *   │   ...  ⌒  ...   │ *   │                 │ *   └───┐         ┌───┘ *       │         │ *       │         │ *       │         │ *       │         └──────────────┐ *       │                        │ *       │                        ├─┐ *       │                        ┌─┘ *       │                        │ *       └─┐  ┐  ┌───────┬──┐  ┌──┘ *         │ ─┤ ─┤       │ ─┤ ─┤ *         └──┴──┘       └──┴──┘ *                神兽保佑 *               代码无BUG! *//*** *      ┌─┐       ┌─┐ + + *   ┌──┘ ┴───────┘ ┴──┐++ *   │                 │ *   │       ───       │++ + + + *   ███████───███████ │+ *   │                 │+ *   │       ─┴─       │ *   │                 │ *   └───┐         ┌───┘ *       │         │ *       │         │   + + *       │         │ *       │         └──────────────┐ *       │                        │ *       │                        ├─┐ *       │                        ┌─┘ *       │                        │ *       └─┐  ┐  ┌───────┬──┐  ┌──┘  + + + + *         │ ─┤ ─┤       │ ─┤ ─┤ *         └──┴──┘       └──┴──┘  + + + + *                神兽保佑 *               代码无BUG! *//*** *                  ___====-_  _-====___ *            _--^^^#####//      \\#####^^^--_ *         _-^##########// (    ) \\##########^-_ *        -############//  |\^^/|  \\############- *      _/############//   (@::@)   \\############\_ *     /#############((     \\//     ))#############\ *    -###############\\    (oo)    //###############- *   -#################\\  / VV \  //#################- *  -###################\\/      \//###################- * _#/|##########/\######(   /\   )######/\##########|\#_ * |/ |#/\#/\#/\/  \#/\##\  |  |  /##/\#/  \/\#/\#/\#| \| * `  |/  V  V  `   V  \#\| |  | |/#/  V   '  V  V  \|  ' *    `   `  `      `   / | |  | | \   '      '  '   ' *                     (  | |  | |  ) *                    __\ | |  | | /__ *                   (vvv(VVV)(VVV)vvv)                 *                        神兽保佑 *                       代码无BUG! *//*** * * *                                                    __----~~~~~~~~~~~------___ *                                   .  .   ~~//====......          __--~ ~~ *                   -.            \_|//     |||\\  ~~~~~~::::... /~ *                ___-==_       _-~o~  \/    |||  \\            _/~~- *        __---~~~.==~||\=_    -_--~/_-~|-   |\\   \\        _/~ *    _-~~     .=~    |  \\-_    '-~7  /-   /  ||    \      / *  .~       .~       |   \\ -_    /  /-   /   ||      \   / * /  ____  /         |     \\ ~-_/  /|- _/   .||       \ / * |~~    ~~|--~~~~--_ \     ~==-/   | \~--===~~        .\ *          '         ~-|      /|    |-~\~~       __--~~ *                      |-~~-_/ |    |   ~\_   _-~            /\ *                           /  \     \__   \/~                \__ *                       _--~ _/ | .-~~____--~-/                  ~~==. *                      ((-&gt;/~   '.|||' -_|    ~~-/ ,              . _|| *                                 -_     ~\      ~~---l__i__i__i--~~_/ *                                 _-~-__   ~)  \--______________--~~ *                               //.-~~~-~_--~- |-------~~~~~~~~ *                                      //.-~~~--\ *                               神兽保佑 *                              代码无BUG! *//***                              _ *  _._ _..._ .-',     _.._(`)) * '-. `     '  /-._.-'    ',/ *    )         \            '. *   / _    _    |             \ *  |  a    a    /              | *  \   .-.                     ; *   '-('' ).-'       ,'       ; *      '-;           |      .' *         \           \    / *         | 7  .__  _.-\   \ *         | |  |  ``/  /`  / *        /,_|  |   /,_/   / *           /,_/      '`-' *//*** ************************************************************** *                                                            * *   .=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-.       * *    |                     ______                     |      * *    |                  .-"      "-.                  |      * *    |                 /            \                 |      * *    |     _          |              |          _     |      * *    |    ( \         |,  .-.  .-.  ,|         / )    |      * *    |     &gt; "=._     | )(__/  \__)( |     _.=" &lt;     |      * *    |    (_/"=._"=._ |/     /\     \| _.="_.="\_)    |      * *    |           "=._"(_     ^^     _)"_.="           |      * *    |               "=\__|IIIIII|__/="               |      * *    |              _.="| \IIIIII/ |"=._              |      * *    |    _     _.="_.="\          /"=._"=._     _    |      * *    |   ( \_.="_.="     `--------`     "=._"=._/ )   |      * *    |    &gt; _.="                            "=._ &lt;    |      * *    |   (_/                                    \_)   |      * *    |                                                |      * *    '-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-='      * *                                                            * *           LASCIATE OGNI SPERANZA, VOI CH'ENTRATE           * ************************************************************** *//*** *                                         ,s555SB@@&amp;                           *                                      :9H####@@@@@Xi                         *                                     1@@@@@@@@@@@@@@8                        *                                   ,8@@@@@@@@@B@@@@@@8                       *                                  :B@@@@X3hi8Bs;B@@@@@Ah,                    *             ,8i                  r@@@B:     1S ,M@@@@@@#8;                  *            1AB35.i:               X@@8 .   SGhr ,A@@@@@@@@S                 *            1@h31MX8                18Hhh3i .i3r ,A@@@@@@@@@5                *            ;@&amp;i,58r5                 rGSS:     :B@@@@@@@@@@A                *             1#i  . 9i                 hX.  .: .5@@@@@@@@@@@1                *              sG1,  ,G53s.              9#Xi;hS5 3B@@@@@@@B1                 *               .h8h.,A@@@MXSs,           #@H1:    3ssSSX@1                   *               s ,@@@@@@@@@@@@Xhi,       r#@@X1s9M8    .GA981                *               ,. rS8H#@@@@@@@@@@#HG51;.  .h31i;9@r    .8@@@@BS;i;           *                .19AXXXAB@@@@@@@@@@@@@@#MHXG893hrX#XGGXM@@@@@@@@@@MS         *                s@@MM@@@hsX#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&amp;,       *              :GB@#3G@@Brs ,1GM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B,      *            .hM@@@#@@#MX 51  r;iSGAM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@8      *          :3B@@@@@@@@@@@&amp;9@h :Gs   .;sSXH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@:     *      s&amp;HA#@@@@@@@@@@@@@@M89A;.8S.       ,r3@@@@@@@@@@@@@@@@@@@@@@@@@@@r     *   ,13B@@@@@@@@@@@@@@@@@@@5 5B3 ;.         ;@@@@@@@@@@@@@@@@@@@@@@@@@@@i     *  5#@@#&amp;@@@@@@@@@@@@@@@@@@9  .39:          ;@@@@@@@@@@@@@@@@@@@@@@@@@@@;     *  9@@@X:MM@@@@@@@@@@@@@@@#;    ;31.         H@@@@@@@@@@@@@@@@@@@@@@@@@@:     *   SH#@B9.rM@@@@@@@@@@@@@B       :.         3@@@@@@@@@@@@@@@@@@@@@@@@@@5     *     ,:.   9@@@@@@@@@@@#HB5                 .M@@@@@@@@@@@@@@@@@@@@@@@@@B     *           ,ssirhSM@&amp;1;i19911i,.             s@@@@@@@@@@@@@@@@@@@@@@@@@@S    *              ,,,rHAri1h1rh&amp;@#353Sh:          8@@@@@@@@@@@@@@@@@@@@@@@@@#:   *            .A3hH@#5S553&amp;@@#h   i:i9S          #@@@@@@@@@@@@@@@@@@@@@@@@@A. * * *    又看源码，看你妹妹呀！ *//*** *_______________#########_______________________ *______________############_____________________ *______________#############____________________ *_____________##__###########___________________ *____________###__######_#####__________________ *____________###_#######___####_________________ *___________###__##########_####________________ *__________####__###########_####_______________ *________#####___###########__#####_____________ *_______######___###_########___#####___________ *_______#####___###___########___######_________ *______######___###__###########___######_______ *_____######___####_##############__######______ *____#######__#####################_#######_____ *____#######__##############################____ *___#######__######_#################_#######___ *___#######__######_######_#########___######___ *___#######____##__######___######_____######___ *___#######________######____#####_____#####____ *____######________#####_____#####_____####_____ *_____#####________####______#####_____###______ *______#####______;###________###______#________ *________##_______####________####______________ *//*** *             ,%%%%%%%%, *           ,%%/\%%%%/\%% *          ,%%%\c "" J/%%% * %.       %%%%/ o  o \%%% * `%%.     %%%%    _  |%%% *  `%%     `%%%%(__Y__)%%' *  //       ;%%%%`\-/%%%' * ((       /  `%%%%%%%' *  \\    .'          | *   \\  /       \  | | *    \\/         ) | | *     \         /_ | |__ *     (___________))))))) 攻城湿 * *        _       _ * __   _(_)_   _(_) __ _ _ __ * \ \ / / \ \ / / |/ _` |'_ \ *  \ V /| |\ V /| | (_| | | | | *   \_/ |_| \_/ |_|\__,_|_| |_| *//*** * https://gold.xitu.io/ *　　　　１１１　　　　　　　　　　　　　　　　　　　　　　　　　１　　　　　　　　　　　 *　　　　１１１　１１１１１１１１１１１１　　　　　　　　　　　１１１　　　　　　　　　　 *　　　　１１　　１１１１１１１１１１１１　　　　　　　　　　１１１１１　　　　　　　　　 *　　　　１１　　１１１　　　　　　　１１　　　　　　　　　１１１１１１１　　　　　　　　 *　　１１１１　１　１１１１１１１１１１１　　　　　　　　　１１１　１１１１　　　　　　　 *　　１１１１１１　１１１１１１１１１１１　　　　　　　１１１１　　　１１１１１　　　　　 *　　１１１１１１　１１　　　　　　　　　　　　　　　１１１１　　　　　１１１１１１　　　 *　　　　１１　　　１１１１１１１１　１１　　　　１１１１１１１１１１１１１１１１１１　　 *　　　　１１　　　１１１１１１１１１１１　　　１１１１１１１１１１１１１１１１１１１　　 *　　　　１１１１１１１１１　１１　　１１　　　　１１　　　　　　１１　　　　　　　　　　 *　　１１１１１１１１１１１１１１１１１１　　　　　　　　　　　　１１　　　　　　　　　　 *　　１１１１　　１１１１１１１１１１１１　　　　　　１１１１１１１１１１１１１１　　　　 *　　１１１１　　１１　　　　１１　　　　　　　　　　１１１１１１１１１１１１１１　　　　 *　　　　１１　　１１　１１　１１　　１１１　　　　　　１１　　　１１　　１１１　　　　　 *　　　　１１　　１１　１１　１１　　１１　　　　　　　１１１　　１１　　１１１　　　　　 *　　　　１１　１１１　１１　１１　　１１　　　　　　　　１１１　１１　１１１　　　　　　 *　　１１１１　１１１　１１１１１１１１１　　　　　１１　１１１　１１　１１１１１１１　　 *　　　１１１１１１　　１１１１１１１１１１　　　　１１１１１１１１１１１１１１１１１　　 *　　　１１　１１１　　　　　　　　　１１１　　　　１１１１１１１１１１１１１１１１１　　 *//*** * https://www.zhihu.com/ *           _____                    _____                    _____                    _____           *          /\    \                  /\    \                  /\    \                  /\    \          *         /::\____\                /::\    \                /::\    \                /::\    \         *        /:::/    /                \:::\    \              /::::\    \              /::::\    \        *       /:::/    /                  \:::\    \            /::::::\    \            /::::::\    \       *      /:::/    /                    \:::\    \          /:::/\:::\    \          /:::/\:::\    \      *     /:::/____/                      \:::\    \        /:::/__\:::\    \        /:::/__\:::\    \     *    /::::\    \                      /::::\    \      /::::\   \:::\    \      /::::\   \:::\    \    *   /::::::\    \   _____    ____    /::::::\    \    /::::::\   \:::\    \    /::::::\   \:::\    \   *  /:::/\:::\    \ /\    \  /\   \  /:::/\:::\    \  /:::/\:::\   \:::\____\  /:::/\:::\   \:::\    \ * /:::/  \:::\    /::\____\/::\   \/:::/  \:::\____\/:::/  \:::\   \:::|    |/:::/__\:::\   \:::\____\ * \::/    \:::\  /:::/    /\:::\  /:::/    \::/    /\::/   |::::\  /:::|____|\:::\   \:::\   \::/    / *  \/____/ \:::\/:::/    /  \:::\/:::/    / \/____/  \/____|:::::\/:::/    /  \:::\   \:::\   \/____/ *           \::::::/    /    \::::::/    /                 |:::::::::/    /    \:::\   \:::\    \      *            \::::/    /      \::::/____/                  |::|\::::/    /      \:::\   \:::\____\     *            /:::/    /        \:::\    \                  |::| \::/____/        \:::\   \::/    /     *           /:::/    /          \:::\    \                 |::|  ~|               \:::\   \/____/      *          /:::/    /            \:::\    \                |::|   |                \:::\    \          *         /:::/    /              \:::\____\               \::|   |                 \:::\____\         *         \::/    /                \::/    /                \:|   |                  \::/    /         *          \/____/                  \/____/                  \|___|                   \/____/          *//*** * http://www.freebuf.com/ *           _.._        ,------------. *        ,'      `.    ( We want you! ) *       /  __) __` \    `-,----------' *      (  (`-`(-')  ) _.-' *      /)  \  = /  ( *     /'    |--' .  \ *    (  ,---|  `-.)__` *     )(  `-.,--'   _`-. *    '/,'          (  Uu", *     (_       ,    `/,-' ) *     `.__,  : `-'/  /`--' *       |     `--'  | *       `   `-._   / *        \        ( *        /\ .      \.  freebuf *       / |` \     ,-\ *      /  \| .)   /   \ *     ( ,'|\    ,'     : *     | \,`.`--"/      } *     `,'    \  |,'    / *    / "-._   `-/      | *    "-.   "-.,'|     ; *   /        _/["---'""] *  :        /  |"-     ' *  '           |      / *              `      | *//*** * https://campus.alibaba.com/ *                                 `:::::::::::, *                             `::;:::::::;:::::::,  ` *                          `::;;:::::::@@@@;:::::::` *                        ,:::::::::::::@    #@':::::` *                      :::::::::::::::'@@      @;:::: *                    ::::::::::::'@@@@'```      .+:::` *                  ::::::::::;@@@#.              ,:::, *                .::::::::+@#@`                   :::: *               :::::::+@@'                       :::: *             `:::::'@@:                         `:::. *            ,::::@@:  `                         :::: *           ;::::::@                            .:::; *          :;:::::;@`        `                  :::; *         :::::::::@`        @                 ;:::: *        :::::::::#`          @`              ,:::: *       :::::::::@`         +@ @             .::::` *      .::::::'@@`       `@@'  @             ::::, *      :::::::++@@@@@@@@@@.                 ::::; *     ;:::::::+,   `..`                    ::::: *    ,::::::::',                          ::::: *    :::::::::+,                         :::::` *   :::::::::+@.                        ,::::.`                     `, *   ::::::;;@+                         .::;::                     `; *  :::::::@@                          `:::;:                   `::`` *  ::::::#@                           ;::::                  .::` *  :::::;@                           :::::`               .;::` *  :::::@                           `:;:::            `::::; *  :::::#                           :::::.        `,;::::: *  ::::::                    `      ::::::,.,::::::::::. *  ,::::::`              .::        ::::::::::::::::;` *   ;::::::::,````.,:::::,          ::::::::::::::. *    :::::::::::::::::: `           `::::::::::` *     `::::::::::::,                  .:::. *         `..` *//*** * http://www.flvcd.com/ *  .--,       .--, * ( (  \.---./  ) ) *  '.__/o   o\__.' *     {=  ^  =} *      &gt;  -  &lt; *     /       \ *    //       \\ *   //|   .   |\\ *   "'\       /'"_.-~^`'-. *      \  _  /--'         ` *    ___)( )(___ *   (((__) (__)))    高山仰止,景行行止.虽不能至,心向往之。 *//*** * 頂頂頂頂頂頂頂頂頂　頂頂頂頂頂頂頂頂頂 * 頂頂頂頂頂頂頂　　　　　頂頂　　　　　 * 　　　頂頂　　　頂頂頂頂頂頂頂頂頂頂頂 * 　　　頂頂　　　頂頂頂頂頂頂頂頂頂頂頂 * 　　　頂頂　　　頂頂　　　　　　　頂頂 * 　　　頂頂　　　頂頂　　頂頂頂　　頂頂 * 　　　頂頂　　　頂頂　　頂頂頂　　頂頂 * 　　　頂頂　　　頂頂　　頂頂頂　　頂頂 * 　　　頂頂　　　頂頂　　頂頂頂　　頂頂 * 　　　頂頂　　　　　　　頂頂頂　 * 　　　頂頂　　　　　　頂頂　頂頂　頂頂 * 　頂頂頂頂　　　頂頂頂頂頂　頂頂頂頂頂 * 　頂頂頂頂　　　頂頂頂頂　　　頂頂頂頂 *//*** * ░░░░░░░░░░░░░░░░░░░░░░░░▄░░ * ░░░░░░░░░▐█░░░░░░░░░░░▄▀▒▌░ * ░░░░░░░░▐▀▒█░░░░░░░░▄▀▒▒▒▐ * ░░░░░░░▐▄▀▒▒▀▀▀▀▄▄▄▀▒▒▒▒▒▐ * ░░░░░▄▄▀▒░▒▒▒▒▒▒▒▒▒█▒▒▄█▒▐ * ░░░▄▀▒▒▒░░░▒▒▒░░░▒▒▒▀██▀▒▌ * ░░▐▒▒▒▄▄▒▒▒▒░░░▒▒▒▒▒▒▒▀▄▒▒ * ░░▌░░▌█▀▒▒▒▒▒▄▀█▄▒▒▒▒▒▒▒█▒▐ * ░▐░░░▒▒▒▒▒▒▒▒▌██▀▒▒░░░▒▒▒▀▄ * ░▌░▒▄██▄▒▒▒▒▒▒▒▒▒░░░░░░▒▒▒▒ * ▀▒▀▐▄█▄█▌▄░▀▒▒░░░░░░░░░░▒▒▒ * 单身狗就这样默默地看着你，一句话也不说。 *//*** *                   /88888888888888888888888888\ *                   |88888888888888888888888888/ *                    |~~____~~~~~~~~~"""""""""| *                   / \_________/"""""""""""""\ *                  /  |              \         \ *                 /   |  88    88     \         \ *                /    |  88    88      \         \ *               /    /                  \        | *              /     |   ________        \       | *              \     |   \______/        /       | *   /"\         \     \____________     /        | *   | |__________\_        |  |        /        / * /""""\           \_------'  '-------/       -- * \____/,___________\                 -------/ * ------*            |                    \ *   ||               |                     \ *   ||               |                 ^    \ *   ||               |                | \    \ *   ||               |                |  \    \ *   ||               |                |   \    \ *   \|              /                /"""\/    / *      -------------                |    |    / *      |\--_                        \____/___/ *      |   |\-_                       | *      |   |   \_                     | *      |   |     \                    | *      |   |      \_                  | *      |   |        ----___           | *      |   |               \----------| *      /   |                     |     ----------""\ * /"\--"--_|                     |               |  \ * |_______/                      \______________/    ) *                                               \___/ *//*** *                        d*##$. *  zP"""""$e.           $"    $o * 4$       '$          $"      $ * '$        '$        J$       $F *  'b        $k       $&gt;       $ *   $k        $r     J$       d$ *   '$         $     $"       $~ *    '$        "$   '$E       $ *     $         $L   $"      $F ... *      $.       4B   $      $$$*"""*b *      '$        $.  $$     $$      $F *       "$       R$  $F     $"      $ *        $k      ?$ u*     dF      .$ *        ^$.      $$"     z$      u$$$$e *         #$b             $E.dW@e$"    ?$ *          #$           .o$$# d$$$$c    ?F *           $      .d$$#" . zo$&gt;   #$r .uF *           $L .u$*"      $&amp;$$$k   .$$d$$F *            $$"            ""^"$$$P"$P9$ *           JP              .o$$$$u:$P $$ *           $          ..ue$"      ""  $" *          d$          $F              $ *          $$     ....udE             4B *           #$    """"` $r            @$ *            ^$L        '$            $F *              RN        4N           $ *               *$b                  d$ *                $$k                 $F *                 $$b                $F *                  $""               $F *                  '$                $ *                   $L               $ *                   '$               $ *                    $               $ *//*** *              ,----------------,              ,---------, *         ,-----------------------,          ,"        ,"| *       ,"                      ,"|        ,"        ,"  | *      +-----------------------+  |      ,"        ,"    | *      |  .-----------------.  |  |     +---------+      | *      |  |                 |  |  |     | -==----'|      | *      |  |  I LOVE DOS!    |  |  |     |         |      | *      |  |  Bad command or |  |  |/----|`---=    |      | *      |  |  C:\&gt;_          |  |  |   ,/|==== ooo |      ; *      |  |                 |  |  |  // |(((( [33]|    ," *      |  `-----------------'  |," .;'| |((((     |  ," *      +-----------------------+  ;;  | |         |," *         /_)______________(_/  //'   | +---------+ *    ___________________________/___  `, *   /  oooooooooooooooo  .o.  oooo /,   \,"----------- *  / ==ooooooooooooooo==.o.  ooo= //   ,`\--{)B     ," * /_==__==========__==_ooo__ooo=_/'   /___________," * *//*** *                 .-~~~~~~~~~-._       _.-~~~~~~~~~-. *             __.'              ~.   .~              `.__ *           .'//                  \./                  \\`. *         .'//                     |                     \\`. *       .'// .-~"""""""~~~~-._     |     _,-~~~~"""""""~-. \\`. *     .'//.-"                 `-.  |  .-'                 "-.\\`. *   .'//______.============-..   \ | /   ..-============.______\\`. * .'______________________________\|/______________________________`. * *//***             无可奉告 一颗赛艇 *  uJjYJYYLLv7r7vJJ5kqSFFFUUjJ7rrr7LLYLJLJ7 *  JuJujuYLrvuEM@@@B@@@B@B@B@@@MG5Y7vLjYjJL *  JYjYJvr7XM@BB8GOOE8ZEEO8GqM8OBBBMu77LLJ7 *  LJLY7ru@@@BOZ8O8NXFFuSkSu25X0OFZ8MZJ;vLv *  YvL7i5@BM8OGGqk22uvriiriii;r7LuSZXEMXrvr *  vv7iU@BMNkF1uY7v7rr;iiii:i:i:ii7JEPNBPir *  L7iL@BM8Xjuujvv77rr;ri;i;:iiiii:iLXFOBJ: *  7ri@B@MOFuUS2Y7L7777rii;:::::i:iirjPG@O: *  7:1B@BBOPjXXSJvrL7rr7iiii:i::::i;iv5MBB, *  r:0@BBM8SFPX2Y77rri::iirri:::::iii75O@G. *  7:SB@BBGqXPk0122UJL::i::r:::i:i;i:v2@Bk. *  ri:MB@BBEqEMGq2JLLL1u7.iX51u77LF27iSB@r, *  ri,v@B@MB8@qqNEqN1u:5B8BOFE0S7ii7qMB@F:: *  ii,J80Eq1MZkqPPX5YkPE@B@iXPE52j7:vBjE7:: *  ii:7MSqkS0PvLv7rrii0@L.Z1iLr::ir:rO,vi:: *  ii::EZXPSkquLvii:iF@N:.,BUi7ri,::UY;r::: *  i::.2ONXqkPXS5FUUEOPP;..iSPXkjLYLLrr:::, *  :::,iMXNP0NPLriiLGZ@BB1P87;JuL7r:7ri:::, *  :::,.UGqNX0EZF2uUjUuULr:::,:7uuvv77::::. *  ::::..5OXqXNJ50NSY;i:.,,,:i77Yvr;v;,,::. *  :::,:.jOEPqPJiqBMMMO8NqP0SYLJriirv:.:,:. *  ,:,,,.,Zq0P0X7vPFqF1ujLv7r:irrr7j7.,,::. *  ,,,....0qk0080v75ujLLv7ri:i:rvj2J...,,,. *  ......8@UXqZEMNvJjr;ii::,:::7uuv...,.,,. *  .....B@BOvX88GMGk52vririiirJS1i.......,. *  .JEMB@B@BMvL0MOMMMO8PE8GPqSk2L:......... *  @B@@@B@M@B@L:7PGBOO8MOMOEP0Xri@B@Mk7,... *  B@B@BBMBB@B@0::rJP8MO0uvvu7..,B@B@B@B@Z7 *  MMBM@BBB@B@B@Br:i,..:Lur:....7@OMMBM@B@@ *  8OOMMMOMMMMBB@B:....,PZENNi..JBOZ8GMOOOO */以上为魔性图以下为神注释/*** * 这个公司没有年终奖的,兄弟别指望了,也别来了,我准备辞职了 * 另外这个项目有很多*Bug* 你坚持不了多久的,拜拜! *//*** * 1只羊 == one sheep * 2只羊 == two sheeps * 3只羊 == three sheeps * 4只羊 == four sheeps * 5只羊 == five sheeps * 6只羊 == six sheeps * 7只羊 == seven sheeps * 8只羊 == eight sheeps * 9只羊 == nine sheeps * 10只羊 == ten sheeps * 11只羊 == eleven sheeps * 12只羊 == twelve sheeps * 13只羊 == thirteen sheeps * 14只羊 == fourteen sheeps * 15只羊 == fifteen sheeps * 16只羊 == sixteen sheeps * 17只羊 == seventeen sheeps * 18只羊 == eighteen sheeps * 19只羊 == nineteen sheeps * 20只羊 == twenty sheeps * 21只羊 == twenty one sheeps * 22只羊 == twenty two sheeps * 23只羊 == twenty three sheeps * 24只羊 == twenty four sheeps * 25只羊 == twenty five sheeps * 26只羊 == twenty six sheeps * 27只羊 == twenty seven sheeps * 28只羊 == twenty eight sheeps * 29只羊 == twenty nine sheeps * 30只羊 == thirty sheeps * 现在瞌睡了吧，好了，不要再改下面的代码了，睡觉咯~~ *//*** * You may think you know what the following code does. * But you dont. Trust me. * Fiddle with it, and youll spend many a sleepless * night cursing the moment you thought youd be clever * enough to "optimize" the code below. * Now close this file and go play with something else. *//*** * 你可能会认为你读得懂以下的代码。但是你不会懂的，相信我吧。 * 要是你尝试玩弄这段代码的话，你将会在无尽的通宵中不断地咒骂自己为什么会认为自己聪明到可以优化这段代码。 * 现在请关闭这个文件去玩点别的吧。 *//*** * somedev1 -  6/7/02 Adding temporary tracking of Login screen * somedev2 -  5/22/07 Temporary my ass *//*** * 一些修改1 - 2002/6/7 增加临时的跟踪登录界面 * 一些修改2 - 2007/5/22 我临时的犯傻 *//*** * 程序员1（于2010年6月7日）：在这个坑临时加入一些调料 * 程序员2（于2011年5月22日）：临你个屁啊 * 程序员3（于2012年7月23日）：楼上都是狗屎，鉴定完毕 * 程序员4（于2013年8月2日）：fuck 楼上，三年了，这坑还在！！！ * 程序员5（于2014年8月21日）：哈哈哈，这坑居然坑了这么多人，幸好我也不用填了，系统终止运行了，you're died *//*** * For the brave souls who get this far: You are the chosen ones, * the valiant knights of programming who toil away, without rest, * fixing our most awful code. To you, true saviors, kings of men, * I say this: never gonna give you up, never gonna let you down, * never gonna run around and desert you. Never gonna make you cry, * never gonna say goodbye. Never gonna tell a lie and hurt you. *//*** * 致终于来到这里的勇敢的人： * 你是被上帝选中的人，是英勇的、不敌辛苦的、不眠不休的来修改我们这最棘手的代码的编程骑士。 * 你，我们的救世主，人中之龙，我要对你说：永远不要放弃，永远不要对自己失望，永远不要逃走，辜负了自己， * 永远不要哭啼，永远不要说再见，永远不要说谎来伤害自己。 *//*** * Dear maintainer: * * Once you are done trying to 'optimize' this routine, * and have realized what a terrible mistake that was, * please increment the following counter as a warning * to the next guy: * * total_hours_wasted_here = 42 *//*** * 亲爱的维护者： * * 如果你尝试了对这段程序进行'优化' * 下面这个计数器的个数用来对后来人进行警告 * * 浪费在这里的总时间 = 42h */Exception up = new Exception("Something is really wrong.");throw up;  //ha ha/*** * When I wrote this, only God and I understood what I was doing * Now, God only knows *//**** 写这段代码的时候，只有上帝和我知道它是干嘛的* 现在，只有上帝知道*/stop(); // Hammertime!// Autogenerated, do not edit. All changes will be undone.// sometimes I believe compiler ignores all my comments// 有时候我相信编译器忽略了我所有的注释/*** * I dedicate all this code, all my work, to my wife, Darlene, who will * have to support me and our three children and the dog once it gets * released into the public. */// drunk, fix later// 有点晕了，以后再修改// Magic. Do not touch.// 麻鸡。勿动。#define TRUE FALSE// Happy debugging suckers// I'm sorry.return 1; # returns 1/*** * Always returns true. */public boolean isAvailable() {    return false;}&lt;!-- Here be dragons --&gt;&lt;!-- 前方高能 --&gt;double penetration; // ouch// 自行了解，不方便解释/////////////////////////////////////// this is a well commented line// To understand recursion, see the bottom of this fileAt the bottom of the file:// To understand recursion, see the top of this file// 想要明白递归须看文件末尾到了文末// 想要明白递归须看文件顶部/* Please work */long long ago; /* in a galaxy far far away */// 很久很久以前 在一个遥远的银河中（出自星球大战）// This code sucks, you know it and I know it.  // Move on and call me an idiot later.// 你我都知道这代码很烂// 先不要骂我2B了，请先继续往下看// I am not sure why this works but it fixes the problem.// 虽然我不知道为什么这样管用，但它却是修复了问题// If this comment is removed the program will blow up// 如果删了此处注释程序就炸了// This function has been here since 1987. DON'T FXXKING TOUCH IT// 这函数1987年就这在了，别他娘动它// if i ever see this again i'm going to start bringing guns to work// 如果要是再让我看见这样的代码，也许我会带着一把枪来上班// no comments for you// it was hard to write// so it should be hard to read// 难写的代码，肯定很难读。因此，我没有注释留给你。// I will give you two of my seventy-two virgins if you can fix this.// 要是你能修正这个问题的话，我会在我的七十二个处女中挑两个送你// I am not responsible of this code.// They made me write it, against my will.// 下面的代码，我不负责。因为是他们逼我写的，违背了我的意愿。/* You are not expected to understand this *//* 你绝不会明白的 */// I have to find a better job// 看来我需要找份更好的工作了/*** * 这个类是Object的子类 */本文来源：传送门]]></content>
      <categories>
        
          <category> 娱乐 </category>
        
      </categories>
      <tags>
        
          <tag> entertainment </tag>
        
          <tag> 趣图 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[读书方法论]]></title>
      <url>/essay/2018/06/06/reading-method/</url>
      <content type="text"><![CDATA[别人与你同样优秀当今社会竞争激烈，好的读书习惯会让自己赢得更大的竞争力，我现在切身体会到读书方法的重要性，感觉有必要记录一下以增强自己这方面的意识。在学校里，我们总是通过课堂老师的指引进行学习，就算没怎么听，也会知道个大概重点，课后也可以通过练习让书本上的知识进一步为自己所吸收。也许还有学习能力特别强的人会说，我也可以全凭自己的能力学习与本专业无关的专业书籍，照样能达到很好的效果。对于这一类人，我想现在这个社会真的不少见，你当然很优秀，但别人同样优秀，这样看的话，你的竞争力并不是很大！独自学习时存在的问题读书遇到结点当你独自一人读书学习的时候，肯定会遇到暂时难以理解的地方，此时，假设你无法通过寻求他人或者老师的帮助来弄懂它，因为术业有专攻嘛，你该怎么办？就算你能找到一个能为你解答疑惑的人，也会存在时效方面的问题。因为你需要寻求帮助的那个人并不是时刻都有空，可能短的话一个小时就会有回应，长的话可能要等到晚上别人休息的时刻，也就是23：00左右。这么算的话，可能一个很小的问题能困扰你最短一天的时间，这期间的你的读书学习效率肯定不会高。长时间下去，你会发现，这么多天过去了，我怎么才看了几十页的书。。。我遇到过一些学习能力很强的大神，他们真正请教别人问题的次数并不多，难道他们天生高智商，天生就是如此优秀，并不是，他们都有一套适合自己的读书方法。他们遇到问题时不会纠结这么多，直接pass，确实觉得影响后续学习进程的话，才会去寻求帮助。当然只是其中之一，好的读书方法能快速提升自己的能力，在单位时间内学习到比别人更多的东西，这就是潜在实力，也就是大家所说的潜能。学习时效另外就是学习效率的问题。一本再简单的专业书籍，你都能看半个月甚至一个月，那你真的不如在课堂上老老实实听老师讲课，那样的话效率更高，收获更多。对于书的类别，也不能笼统的采用以前常说的那种“万能写作模板”的东西，任何东西都不是万能的，就像我现在所说的读书方法论，也许只适合我一个人而已，对于你们来说，我现在所说的全是废话。不同类型的书，要采取不同的方式去学，是偏理论的、还是偏实践的，是偏概念的，还是偏计算的，是扫盲性质的，还是学习更高深学问的基础……对于这些不同类别的书籍，读书的方式是不同的。花多一点时间在重要的点上，其余东西直接扫一下就OK，就算记不住之后有个印象翻一下就行。以点带面，这是最快的学习方式。个人素养独自学习的最难的地方在于，你得耐得住寂寞。别拿着书，茫然的看着手机，听着音乐，意义何在。确实想玩的话，不如。。。看电影，不如。。。去浪，不如。。。疯狂。别在学习的时候想着去放松，别在玩的时候想着还有几页书没看完，搞得自己难受，自己作死。一个能正确处理读书学习和放松心灵两者关系的人，才会有所收获。当然还有心态方面的问题。你读这本书的目的是什么，是学习知识？是掌握一项技能？是解决问题？还是仅仅休闲乐趣？明确你的读书目的，不为读书而读书，不为学习而学习。但是目的性太强也会让自己有压力感（当然有时候是需要这种压迫感），学习起来并不会轻松，长期这样下去就是失去读书的兴趣，非常不划算。读书应该是让人收益终身的一件事，把读书当作一种陶冶情操，提升自己生活品质和素养的日常事情，乐在其中，最后真正达到那种不为任何目的的读书行为才是我们所应该追求的，因为那种目的性早已在你潜意识中，拿到一本书，就知道自己怎么读，就该知道自己想从中得到什么。不为目的目的，才是读书最为明确的目的。读书方法理清书的结构拿到一本新书，先看目录，而且得细看，这件事真的是很容易忽略掉。熟悉目录之后你就能站着高处俯瞰全书的脉络，哪一部分是这本书的核心部分，该花多一点时间去钻研；哪一部分是只是了解，花少一点儿时间去大概看一下就行。然后尝试直接跳过基础部分抓重点，有什么不理解的地方再去看细看前面的基础部分，等你把核心部分学完之后，这本书就基本上学完了，挑一些自己感兴趣的部分再细看一下，其余部分甚至不用看，因为那些不经常用的东西看了也会忘记，真正重要的东西肯定会经常出现。以点带面对任何一本书，每一部分都会有它自己存在的价值，找到每一部分的价值点，弄懂这个核心部分，这个部分就已经发挥了它的存在作用。这样的话，你就可以很快的学完一本书。掌握了书中各种重要的点，全书的结构就会再一次清晰，这个时候你站的高度不同，看待这本书的态度也会不同。就像大家所熟知的“温故而知新”，这其实就是每次读完一本书，站在这本书的高度就不同，看到的东西自然就不一样了。所以，你得先快速达到这个高度，才能以不同的视角去看待书中的点，分清次重点，理清点与点之间的联系和区别，以点连线，以线成面。竞争意识拥有强大的竞争意识会让你的学习效率得到意想不到的提高，可能这会有点累，但是，这的确是一种快速学习的方法。短时间内如何掌握更多的知识不正是为了适应当今快速发展的社会所需要的能力吗。当你在读一本书的时候，已经有成千上个人学习了这本书，而且比你了解得更透彻，学习得更深入，你自己该怎么做才能达到别人的水平。有这个意识在里面，自己学东西的速度肯定会更快，学习的深入度更大。同时，相信自己也很重要，就算欺骗自己也行，我比任何人都学得快，比任何人都学得深入，当然自己想想就行，如果说出来的话不被打成残废那就奇怪了哈哈哈！洞察力虽然说洞察力这东西说起来有点不太实在，每个人的眼光不一样，看待同一本书的态度也不一样。这么说吧，对于那些比较经典的书，得到了大家的好评，这些书读起来肯定没有坏处，毕竟经受住了这么多的考验，一本好的书不会有很少的评价，甚至一群人差评，那也值得注意一下，我相信一本烂书，我是评论都懒得写的。问题是如何发现那些在不久的将来会成为经典的书籍，提前掌握别人不了解的知识，时刻走在时代前沿，这就需要个人的洞察力。每个人的精力都有限，所以我们只需要关注自己感兴趣的方向就行，及时洞察自己相关领域的发展趋势和新技术，提前做好迎接新时代的准备。正确对待不同类型的书拿到一本书，首先你得先清楚这是一本什么类型的书吧。可读性不强的专业书对于专业性很强的书，有大量的专业性术语，并且可读性不强，难以理解，我可以肯定的说这80%是一本好书，学透它你会有很大的收获。但是读不下去怎么办，别急，对于一本有大量干货的好书，网上肯定有前人总结好的东西，这些东西更容易理解，你就按照书中的指引，结合网上的资料，独立去学，虽然慢一点，学到的东西真的很多很多。这种类型的书真的需要多读一些，习惯之后，也不过如此。3.5.2 可读性强的专业书对于可读性强的专业书籍，那就要提高速度了，既然可读性强，那学习起来自然比较容易接受，会比那些可读性不强的书快很多，正如我之前所说的抓重点就行，不懂的再查找细看，这样的好书其实并不多，所以好好享受这种类型的书的学习吧哈哈哈。记忆或者概念之类的书还有一种类型的书很头痛，那就是需要大量记忆的书籍，能用理解解决就用理解方式去学习，能抽象化就抽象化。剩下的东西就那些，必须掌握，必须记忆，这个就看个人的情况了，涉及到记忆方法我相信每个人都有自己的方式吧。扫盲性质的书对于科普型的书，那种扫盲性质的，看一下就可以了，了解一下大概，掌握核心部分就OK了，不必深究。框架书或流程式的工具书最后就是流程式的指导书之类的书，工具或者框架的学习使用，这种类型大家见得比较多，一般大家都会说，多实践就行了，多自己在电脑中实现几次就OK了。我不想否认这种方式，因为我以前就是这么干的哈哈哈。但是，我有了新的方式，那就是总结出适合自己的模板，套路，把它总结出来存在笔记和博客之类的地方，方便日后查看。既然是工具类型的不用的话是真的会忘，也需短时间内你会大量使用这个工具或者框架，你当然会认为自己都掌握了。但辞职或者转行之后，这种东西也许你就用不到了，你就相当于慢慢失去了这点知识，但是如果当初你总结了自己的套路，模板，以后在回过头学的时候会更快，知识恢复时间更快。记笔记我个人认为边读书边记笔记很重要，而且要直接在书中记，这样以来为而后重新翻阅的时候容易理解，记忆更深刻；另一方面，可以让自己在记笔记的过程中学习的印象加深。有人肯定会反驳我，直接在本子上或者电脑上记不行吗？不是不行，只是在书上记笔记这一环不能少，如果你认为有总结的必要，书上的笔记会让你总结起来更有侧重点，更有条理性，方便日后查阅。碎片化时间的利用一天中零碎的时间真的很多很多，利用起来就是几个小时的了。对于大多数朋友而言，这些零碎的时间基本上都浪费了，都拿去刷手机去了。合理化碎片时间，比喻地铁上看电子书，但我是接受不了这种方式，我选择看一个ppt或者知识框架图；比喻中午午休之前，拿及其专业难懂的书籍催眠（作死行为作用不大）；比喻晚上睡觉前，最适合拿来写当天读书总结，或者打代码，写一点技术总结；比喻出去游玩或者休闲时刻，我选择看一下最新科技时政财经新闻；甚至可以利用一两分钟的空闲时间去背一个单词（个人还做不到这种境界）……狩猎范围狩猎领域和范围很重要，如果一个人只专注于自已的领域，就算他最后取得的成绩再好，成就再大，未免他的人生也太单调了吧。所以我建议对于一些自己感兴趣的领域但不是自己的领域，应该多了解学习；而对于那些通用型领域，更应该深入了解，比别人学习得更深入（其实不是学习，只是提醒自己关注一下，多细致观察这方面的套路），才能在人际关系中游刃有余…..总之，尽可能的让自己的其他领域狩猎范围更广，在自己感兴趣的领域和自己专业特长领域则要求了解更深入，有了这样的广度和深度，那你就真的很强很强了。个人的一点感想“人生天地之间，若白驹过隙，忽然而已。”当你意识到读书的乐趣及其重要性，你会发现时间真的快得飞起。而那些日常琐事，困扰你的烦心事，都烟消云散；你之前所有的遗憾，所有的不堪，所有的迷茫，都不值一提；你之前所有的成就，所有的荣耀，所有赞誉，都渺小如蝼蚁……在每个人的一生中，都会有一个很特别的时刻，自己在这一瞬间成长，知道自己该干什么，自己想要什么。此时再回过头看看过去的自己，希望留给你的只是天真快乐的少年时光，而不是一堆感慨遗憾。在该成长的时刻长大真的是一件很幸运的事情，哈哈哈哈！从年少被别人逼着读书，到后来的逃避读书，再到现在的爱上读书；从一个村里公认的天才，到荒废后的渣渣，再到后来的黑马，最后归于现在的普通人中的一员，可谓是戏剧性人生了哈哈哈。最后，送给大家一句话，诸君共勉！“学习使我快乐，读书使我成长。”哈哈哈哈哈！！！]]></content>
      <categories>
        
          <category> essay </category>
        
      </categories>
      <tags>
        
          <tag> essay </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[图床以及在线分享演示文稿]]></title>
      <url>/2018/04/26/%E5%9B%BE%E5%BA%8A%E4%BB%A5%E5%8F%8A%E5%9C%A8%E7%BA%BF%E5%88%86%E4%BA%AB%E6%BC%94%E7%A4%BA%E6%96%87%E7%A8%BF/</url>
      <content type="text"><![CDATA[关于图床什么是图床？这并不是一个多么高大上的名词概念！用比较通俗的话来说，当你在撰写新文章时，你需要去插入图片以使得你的文章内容更加直观、易懂，这个时候有以下几种办法：  在博客根目录的 source 文件夹下新建一个image文件夹专门存放图片，在博文中引用的图片路径为 /image/图片名.后缀![](图片路径)  对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源，将站点配置文件中的post_ asset _folder 选项设为 true 来打开文章资源文件夹  post _asset_folder: true然后再博文中通过相对路径引用 { asset _img 图片文件名%}  我们知道Github的主机还在国外，虽说目前访问速度还不算慢的，可是不论是Github还是Coding，项目容量都是有限的，不可能放入太多图片文件。 如果在项目文件中以相对路径引用的话，会出现跳转页面时一些图片路径会错误；使用绝对路径引用的话，会出现重定向的问题，浏览器可能会报302异常，使浏览器上的绿色小锁头不见了(这个不能忍……)。  使用第三方云服务储存，把图片放在国内的图床上是个更好的选择，虽然绝大多数云服务提供商都是收费(或是会有会员免费体验期或是按月分发一些免费容量)的，但在这个巨大的网络缝隙中，还是能找到其他一些可取的方法去满足我们(贫穷的学生党，嘤嘤嘤~~)，下面我会列出一些我所找到的可取之径：国内  阿里云  腾讯云  百度云  网易云  七牛云  又拍云  亿方云  坚果云  500px  上传照片到微博微相册QQ空间相册其实也是可以的，只是这类处理方法也比较麻烦lo…上面这些都是目前国内一些在云服务方面较为主流的、实力也比较可靠的服务提供商，很多带有CDN加速处理，加载起来会更快。但可能有时候会因为容量太少的问题等，给劳苦大众带来一些不愉快，所以啊，还是广泛地搜集了一波国内其他一些的图床服务，其实这也是为了应对自己的不时之需，毕竟国内做图床服务这方面的不稳定性真的是…跌宕起伏(哎，抬头看向窗外，长城的方向)| 图床服务 | 个人评价 ||:-:|:-:||SM.MS |⭐⭐⭐⭐||cheveieto|⭐⭐⭐⭐|| 路过图床	|⭐⭐⭐||uploader	|⭐⭐⭐||贴图库	|⭐⭐⭐||Clantu云相册	|⭐⭐⭐||淡然图床	|⭐⭐⭐||随意云|⭐⭐⭐||MPic-图床神器|⭐⭐⭐||爱信息图床	|⭐⭐⭐||Gimhoy图床	|⭐⭐||萝莉图床|⭐⭐|国外  CloudApp————国内可访问，个人很推荐这个应用  Dropbox————墙了  Flickr————墙了关于在线分享演示文稿在线分享演示文稿在在线分享演示文稿这个标题的选择上，斟酌了好久，🙊就感觉怎么用最少的汉字来准确完整地将这项design tool 的作用与应用领域给表达出来…直接用一个实例展示一下吧~点击查看工具分享目前我遇到的主要就是这两个，以后要是遇到相关的、喜欢的会再补充。  SpeakerDeck————墙了  Slides————国内可访问，个人很推荐这个应用待补充…]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> Tool </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[走进Markdown园子]]></title>
      <url>/2018/04/11/%E8%B5%B0%E8%BF%9BMarkdown%E5%9B%AD%E5%AD%90/</url>
      <content type="text"><![CDATA[  起初也就是打算简单一些Markdown在编辑Blog方面的一些常用操作和注意事项，没想到，一下没刹住，毫无防备地闯进了这个好趣的园子….1. 认识 Markdown  HTML(HyperText Markup Language)作为一种超文本标记语言(markup language)应运而生，无数的网页从此有了主次分明，层次清晰的格式。如果将HTML比作一架重机枪，那么Markdown就是一把手枪，满足了主要的文本格式标记的需求，可是操作性却大大简化。秉承「易读易写」的宗旨，Markdown作为一种轻量级标记语言(lightweight markup language)，让无数的程序猿和文字工作者爱不释手。1.1 Markdown的优点  专注你的文字内容而不是排版样式，安心写作。  轻松的导出 HTML、PDF 和本身的 .md 文件。  纯文本内容，兼容所有的文本编辑器与字处理软件。  随时修改你的文章版本，不必像字处理软件生成若干文件版本导致混乱。  可读、直观、学习成本低。1.2 对Markdown的误解  We believe that writing is about content, about what you want to say – not about fancy formatting.我们坚信写作写的是内容，所思所想，而不是花样格式。    —-  Ulysses for MacMarkdown 旨在简洁、高效，也由于 Markdown 的易读易写，人们用不同的编程语言实现了多个版本的解析器和生成器。这就导致了目前不同的 Markdown 工具集成了不同的功能（基础功能大致相同），例如流程图与时序图，复杂表格与复杂公式的呈现。虽然功能的丰富并没有什么本质的缺点，但终归有些背离初衷，何况在编写的过程中很费神，不如使用专业的工具撰写来的更有效率，所以如果你需实现复杂功能，专业的图形界面工具会更加方便。当然，如果你对折腾这些不同客户端对 Markdown 的定制所带来高阶功能感到愉悦的话，那也是无可厚非的。1.3 Markdown官方文档官方的 Markdown 语法规则文档，当然，后文我也会用自己的方式，阐述这些语法在实际使用中的用法。  创始人 John Gruber 的 Markdown 语法说明  Markdown 中文版语法说明2. 使用Markdown2.1 标题Markdown通过在行首添加1-6个#符号来定义不同级别的标题，最多到六级标题。注意#后需要加一个空格。书写格式如下：#h1##h2二级标题######h6六级标题特别的，还可使用=(高阶标题)和-(次阶标题)标记一级和二级标题。书写格式如下：这是高阶标题(效果和一级标题一样)=这是次阶标题(效果和二级标题一样)-注意：=和-标记标题时，=和-的个数在不同的编辑器中都有不同，只要1个或者大于等于两个又或者必须要三个(含三个)以上的才可以表示，这倒不是多大的问题了，简单试试就知道了。2.2 加粗、斜体和删除线  markdown使用*和_来强调文本，使用一个*和_包围的文本会被转化为斜体，而用两个*和_包围的文本则会被转化成加粗，使用两个~包围的文本会被转化为删除线。  但是如果你的 * 、 _和 ~ 两边都有空白的话，它们就只会被当成普通的符号  如果要在文字前后直接插入普通的星号或底线，你可以用反斜线书写格式如下：*斜体文字*_斜体文字_**加粗文字**__加粗文字__~~删除内容~~解析效果如下：斜体文字斜体文字加粗文字加粗文字删除内容2.3 列表Markdown支持无序列表和有序列表。无序列表可以使用*，+，-三者中任意符号来标记；有序列表则使用数字加.来标记。注意标记后面需要加上一个空格，有序列表的数字会被按顺序自动更正。书写格式如下：**有序列表**1. 第一点2. 第二点4. 第三点**无序列表**- 这是无序列表项目+ 这是无序列表项目* 这是无序列表项目解析效果如下：有序列表  第一点  第二点  第三点无序列表  这是无序列表项目  这是无序列表项目  这是无序列表项目两个列表之间不能相邻，否则会解释为嵌套的列表。下面这个是嵌套的列表书写格式如下：* 呵呵    + 嘉嘉    + 嘻嘻    + 吼吼        - 嘎嘎        - 桀桀* 哈哈解析效果如下：  呵呵          嘉嘉      嘻嘻      吼吼                  嘎嘎          桀桀                      哈哈注意：  标记后面最少有一个空格或制表符。  若不在引用区块中，必须和前方段落之间存在空行，后面最好还是空一行，否则会解释为嵌套的列表。  有序列表标记不是按照你写的数字进行显示的，而是根据当前有序列表标记所在位置显示的，如示例1所示。  无序列表的项目符号是按照实心圆、空心圆、实心方格的层级关系递进的。通常情况下，同一层级使用同一种标记表示，便于自己查看和管理。2.4 引用在段落前添加一个&gt;符号即可将该段落标记为引用，注意&gt;后需要添加一个空格。书写格式如下：&gt; 这是引用解析效果如下：  这是引用繁琐一点，你也可以在引用段落的每一行都加上&gt;符号。并且&gt;可以迭代使用，表示引用中的引用效果。书写格式如下：&gt; 这是一级引用&gt;&gt; 这是二级引用&gt;&gt;&gt; 这是三级引用&gt; 这是一级引用解析效果如下：  这是一级引用      这是二级引用          这是三级引用        这是一级引用再如：书写格式若如下：&gt; 这是一级引用&gt;&gt; 这是二级引用&gt;&gt;&gt; 这是三级引用&gt; 这是一级引用解析效果则：  这是一级引用      这是二级引用          这是三级引用这是一级引用        从上面两例可看出，如果&gt;、»和»&gt;等嵌套使用的话，从»&gt;退到&gt;时，必须之间要加上一个空行作为过渡，否则默认为下一行和上一行是同一级别的引用。如上例所示。  引用完之后，必须再空一行，重新一个新的开始，否则，以后的文字都将在引用的范围内，不要问我为什么，实践出真知。  引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等(见下面的解析效果)：即，书写格式如下：&gt; ## 这是一个标题。&gt;&gt; 1.   这是第一行列表项。&gt; 2.   这是第二行列表项。&gt;&gt; 给出一些例子代码：&gt;&gt;     return shell_exec("echo $input | $markdown_script");解析效果则：  这是一个标题。      这是第一行列表项。    这是第二行列表项。    给出一些例子代码：    return shell_exec("echo $input | $markdown_script");  2.5 分割线分割线最常使用就是三个或以上*，还可以使用-和_。书写格式如下：***___---解析效果如下*注意：  只要*或者-大于等于三个就可组成一条平行线。  使用---作为水平分割线时，要在它的前后都空一行，防止---被当成标题标记的表示方式。2.6 插入链接markdown文本中插入链接非常方便，有文内链接和引用链接两种方式。注意如果链接的是本地资源，则链接地址为当地资源的路径。书写格式如下：**文内链接**这是一个文内链接的[例子](http://example.com/ "鼠标悬浮此处显示的标题")。[这个](http://example.net/)链接在鼠标悬浮时没有标题。[这个](/about/)链接是本地资源。**引用链接**这是一个引用链接的[例子][id]。[id]: http://example.com/  "鼠标悬浮标题（可选）"**注意，这里的id没有大小写区分，如果省略id，则前面方括号的内容会被用作id。**我常用的网站包括[Google][1] ，[Yahoo][2] 和 [MSN][3]。[1]:	http://google.com/        "Google"[2]:	http://search.yahoo.com/  "Yahoo Search"[3]:	http://search.msn.com/    "MSN Search"**也可以写成**我常用的网站包括[Google][]，[Yahoo][]和[MSN][]。[google]: http://google.com/        "Google"[yahoo]:  http://search.yahoo.com/  "Yahoo Search"[msn]:    http://search.msn.com/    "MSN Search"解析效果如下：文内链接这是一个文内链接的例子。这个链接在鼠标悬浮时没有标题。这个链接是本地资源。引用链接这是一个引用链接的[例子][id]。[id]: http://example.com/  “鼠标悬浮标题（可选）”注意，这里的id没有大小写区分，如果省略id，则前面方括号的内容会被用作id。我常用的网站包括[Google] [1] ，[Yahoo] [2] 和 [MSN] [3]。[1]: http://google.com/        “Google”[2]: http://search.yahoo.com/  “Yahoo Search”[3]: http://search.msn.com/    “MSN Search”也可以写成我常用的网站包括Google，Yahoo和MSN。注意：  上述的[1]: http://google.com/  "Google"、[google]: http://google.com/        "Google"等等之类不会出现在区块中。  文内链接和引用链接显示效果是一样的。但是在编辑状态下的使用情况不一样。文内链接紧跟链接文字，可以在看到链接文字的同时清楚的知道链接地址，但是不便于多次重复利用。引用链接可以重复使用，但一般都是将一些链接放在一起统一管理，如一段文字后面或文章结尾，因此在找到链接和链接文字的对应关系上有些麻烦。各有利弊了，分情况使用。  我原以为所有Markdown编辑器都支持这种引用链接的，经过测试，发现CSDN中是支持的，但后来惊奇地发现，引用链接这种方式在简书的Markdown编辑工具下以及在我的这个GitHub Pages中是无法解析的。2.7 插入图片  插入图片和插入链接非常类似，只是在方括号前多一个!。插入图片语法：![Alt text](/path/to/img.jpg "Optional title")      Alt text为如果图片无法显示时显示的文字。    /path/to/img.jpg为图片所在路径。    Optional title为显示标题。显示效果为在你将鼠标放到图片上后，会显示一个小框提示，提示的内容就是Optional title。  书写格式如下：**文内链接：**![图灵社区](http://www.turingbook.com/Content/img/Turing.Gif)**引用链接**[图灵社区][1]![图灵社区Logo][2][1]: http://www.ituring.com.cn[2]: http://www.turingbook.com/Content/img/Turing.Gif解析效果如下：文内链接：引用链接[图灵社区][1]![图灵社区Logo][2][1]: http://www.ituring.com.cn[2]: http://www.turingbook.com/Content/img/Turing.Gif注意：  同上节链接一样，引用链接这种方式在简书的Markdown编辑工具下以及我的这个GitHub Pages中是无法解析的。  同时，注意一点：到目前为止， Markdown 还没有办法指定图片的宽高。2.8 表格表格的书写格式一目了然，还是很方便简洁的。书写格式如下：| 左对齐 | 中间对齐 | 右对齐 || :-     |  :-:     |   -:   || 左1    |  中1     |  右1   || 左2    |  中2     |  右3   |解析效果如下：            左对齐      中间对齐      右对齐                  左1      中1      右1              左2      中2      右3      注意：  简书、CSDN中都是能够完整正确解析出表格的；  但不知道为什么，CSDN中表格中的居中、居右不能正确解析出来…sad2.9 脚标 (脚注)不同于链接，这里的脚标内容会被放在文末，点击可以实现跳转，使用[^]来定义脚注。书写格式如下：使用 Markdown[^1]可以效率的书写文档, 可以使用 Leanote[^Le] 编辑器进行书写.[^1]:Markdown是一种纯文本标记语言[^Le]:开源笔记平台，支持Markdown和笔记直接发为博文解析效果如下：使用 Markdown1可以效率的书写文档,可以使用 Leanote2 编辑器进行书写.2.10 其他2.10.1 上下标书写格式如下：E = mc&lt;sup&gt;2&lt;/sup&gt;Water: H&lt;sub&gt;2&lt;/sub&gt;O解析效果如下：E = mc2 Water: H2O2.10.2 直接链接与邮箱在markdown中将链接地址或邮箱地址用&lt;&gt;包围，则会被自动转换成可点击的链接。书写格式如下：&lt;http://haoeric.com&gt;&lt;haoeric0520@gmail.com&gt;解析效果如下：http://haoeric.comhaoeric0520@gmail.com注意：之前在简书、CSDN中测试都是没有问题的，现在我在Cmd Mardown中重新编辑测试，这里的邮箱竟然会出问题（显示不出来），可能这就是不同平台编辑器下的区别吧…2.10.3 换行使用html标签&lt;br/&gt;、&lt;br&gt;换行书写格式如下：第一行hahaha&lt;br/&gt;第二行6666解析效果如下：第一行hahaha第二行66662.10.4 反斜杠如果需要避免文本中的符号被当做markdown标识符而发生不必要的格式转化，可以在符号前加\来避免。书写格式如下：\*不是斜体\*解析效果如下：* 不是斜体 *给出Markdown支持的转义字符列表：\   反斜线`   反引号*   星号_   底线{}  花括号[]  方括号()  括弧#   井字号+   加号-   减号.   英文句点!   惊叹号2.10.5 代码高亮使用栅栏标记代码块的一个好处是可以标明代码的语种，然后实现代码的高亮。书写格式如下：  `ruby         require 'redcarpet'      markdown = Redcarpet.new("Hello World!")      puts markdown.to_html  \`解析效果如下：require 'redcarpet'markdown = Redcarpet.new("Hello World!")puts markdown.to_html注意：  貌似目前简书还没有支持代码高亮….sad2.10.6  关于锚点网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转，可参考Github。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。在Github的md 文件中，会为每个h1~h6标签，自动塞入一个a标签，并渲染好id。比如：# h1以上md语言被渲染成html如下：&lt;h1&gt;	&lt;a id="user-content-h1" class="anchor" href="#h1" aria-hidden="true"&gt;		&lt;svg aria-hidden="true" class="octicon octicon-link" height="16" role="img" version="1.1" viewBox="0 0 16 16" width="16"&gt;			&lt;path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"&gt;			&lt;/path&gt;		&lt;/svg&gt;	&lt;/a&gt;	h1&lt;/h1&gt;不去管svg部分，可以看到h1标签内嵌入了一个id为 "user-content-h1"的a标签，如果标题为# h5，那么id就会是 user-content-h5 。这样就可以用类似下面的语句对其进行跳转定位：快点我，我要跳转到h1所在的位置效果:  一点击快点我，我要跳转到h1所在的位置,即跳转到h1所在的位置。还有一种常见的书写格式如下： ## &lt;span id=a&gt; 标题a &lt;/span&gt;跳转到[标题a](#a)解析效果如下： ## &lt;span id=a&gt; 标题a &lt;/span&gt;跳转到标题a注意：  尽管在某些Markdown编辑工具下是无法解析的，比如简书。  我已经分别在GitHub和CSDN上测试过以上两种锚点方式，结果可行！2.11 Markdown的局限性  Markdown没有居中和右对齐功能，除非做扩展.  不同的Markdown工具功能会不一样，高级功能并不是都有的.  部分Markdown工具不支持语法高亮，不显示代码行号.  目录索引很重要，写技术类文章条理很重要，在开篇有个目录，非常有必要.  部分Markdown工具不支持编辑 LaTex数学公式，这是非常必要的功能.2.12 细节要点（updating…）  首行缩进：在段首加入&amp;emsp;、&amp;ensp;、&amp;nbsp;来输入空格，其中，&amp;emsp;是一个中文字符，&amp;ensp;是半个中文字符 ，&amp;nbsp;是1/4中文字符。  [数字] + . + [空格]的形式会呼出有序的项目列表。因此如果你在正文中恰好出现这种形式，那么可以在.的前面加上\来避免出现有序列表。  引用区块&gt;和代码区块 `有不同的用途：`&gt;`引用区块中的文本保留Markdown语法，而` 代码块中的文本不保留Markdown语法。2.13 补充（updating…）2.13.1 图片图床插入图片的地址需要图床(什么是图床呢???)，这里推荐围脖图床修复计划与CloudApp的服务，生成URL地址即可。图床，顾名思义，图片床，即大量图片汇聚地，每一张图片都有一个url,供所需站点使用。推荐工具  七牛云  围脖图床修复计划  CloudApp2.13.2 LaTeX公式  $表示行内公式例子如下：爱因斯坦发明的质能方程是：$E=mc^2$显示效果：爱因斯坦发明的质能方程是：$E=mc^2$  $$表示整行公式例子如下：$$\sum_{i=1}^n a_i=0$$  $$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$$$\sum^{j-1}_{k=0}{\widehat{\gamma}_{kj} z_k}$$显示效果：注意：  访问MathJax参考更多使用方法；  CSDN、Cmd Markdown这里都是可以解析的，But在某些Markdown编辑工具下是无法解析的，比如简书、我的这个GitHub Pages中。2.13.3 流程图例子如下：flowst=&gt;start: Start:&gt;https://www.zybuluo.comio=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io显示效果：flowst=&gt;start: Start:&gt;https://www.zybuluo.com io=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutine e=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io注意：  更多语法参考: 流程图语法参考；  在某些Markdown编辑工具下是无法解析的，比如CSDN、Cmd Markdown、简书。2.13.4 其他某些平台特有语法(updating…)  GitHub  Github中的emoji表情Github的Markdown语法支持添加emoji表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情。比如 :blush:，可以显示 :blush:  更多表情符号点这里：emoji3. Markdown 工具的选择3.1 Mac 平台在 Mac OS X 上，用  Mou 这款免费且十分好用的 Markdown 编辑器，它支持实时预览，既左边是你编辑 Markdown 语言，右边会实时的生成预览效果。其次还有很多同类选择。如果你是个编辑作者，建议你购买 Ulysses Ⅲ，这款应用入围了苹果2013年 Mac App Store 的 The Best of 2013，相比 Mou 它支持更多的写作格式、多文档的支持。Mou、iA Writer 这些应用都是基于单文档的管理方式，而 Ulysses Ⅲ 支持 Folder、Filter 的管理，一个 Folder 里面可以创建多个 Sheet，Sheet 之间还可以进行 Combine 处理。3.2 Linux 平台ReText、Cmd Markdown、vim、 Mango、Haroopad  以vim为例在vim中写markdown，首先安装语法高亮的插件－－vim-markdown．至于预览，则有很多方式：      使用vim插件－－vim-instant-markdown    此方法可以实现markdown实时预览，不过得首先安装nodejs和npm．详细的安装过程见vim插件汇总－－Markdown插件．    vim其他插件－－python-vim-instant-markdown    通过＂Markdown.pl＂转换成html在浏览器预览    见博文 vim与markdown ．该方式得手动预览．    使用Pandoc    利用 Pandoc 预览 VIM 中书写的 Markdown          chrome插件－－Markdown Preview Plus    vim编辑markdown时实现预览   关于产生文章目录的几种方式        安装完插件－－vim-markdown后，在vim中直接输入命令:Toc即可打开显示目录的窗口。    安装插件－－tagbar，并参考markdown配置设置即可，注意  g:tagbar_type_markdown 和 ‘ctagstype’: ‘markdown’ 这两个地方需要和你的 vim 所识别的 markdown 格式匹配。检测自己的 vim 所识别的 markdown 文本的格式的方式是在 vim 中输入 :set filetype? ，所显示的 filetype= 后面的内容如果不是markdown，则需要用来替换上面两个地方。    并且'ctagsbin' : '/path/to/markdown2ctags.py',中的/path/to必须替换成自己的路径。      安装插件－－VOoM和VOoM(原VOOF)：vim实现带折叠双栏树状文本管理。    如果想将markdown转为带目录的html文件并在浏览器中预览，可使用githhub项目－－i5ting_ztree_toc。  3.3 Window 平台Windows 下的 Markdown 工具，有两款还算不错，一款叫  MarkdownPad ，另一款叫 MarkPad。就我知道的，还有马克飞象、Cmd Markdown相关编辑器。3.4 IOS平台iOS 端已有相当多的 app 支持 Markdown 语法编辑，例如 Drafts、Day One、iA Writer 等。3.5 Web平台Web 端上，推荐 简书这款产品，上面有无数热爱文字的人在不停的创造、分享。简书的Web 端使用 Markdown 很舒服，它同样支持左右两栏的实时预览，字体优雅、简洁。同样是 Web 端， Draftin 、 马克飞象、 Dillinger.io 、Cmd Markdown、Markable.in这些在线 MD 编辑器也还都不错。3.6 高级应用当然，这里不能少了一款非常精巧的文本编辑器，适合编写代码、做笔记、写文章。它用户界面十分整洁，功能非同凡响，性能快得出奇。它就是 Sublime！！！具体可阅览Sublime通过插件实现自如编辑Markdown文档的 教程。如有更好的 Markdown 免费编辑器推荐，请到这里留言反馈，谢谢！4. 更多链接  MarkDown学习笔记  首次使用MarkDown好激动  让你的Markdown用起来得心应手  一段JS代码让Markdown自动生成侧边栏目录  Markdown 语法说明 (简体中文版)            Markdown是一种纯文本标记语言 &#8617;              开源笔记平台，支持Markdown和笔记直接发为博文 &#8617;      ]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> Markdown </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MathJax with Jekyll]]></title>
      <url>/test/2018/02/16/Mathjax-with-jekyll/</url>
      <content type="text"><![CDATA[One of the rewards of switching my website to Jekyll is theability to support MathJax, which means I can write LaTeX-like equations that getnicely displayed in a web browser, like this one \( \sqrt{\frac{n!}{k!(n-k)!}} \) orthis one \( x^2 + y^2 = r^2 \).What’s MathJax?If you check MathJax website (www.mathjax.org) you’ll seethat it is an open source JavaScript display engine for mathematics that works in allbrowsers.How to implement MathJax with JekyllI followed the instructions described by Dason Kurkiewicz forusing Jekyll and Mathjax.Here are some important details. I had to modify the Ruby library for Markdown inmy _config.yml file. Now I’m using redcarpet so the corresponding line in theconfiguration file is: markdown: redcarpetTo load the MathJax javascript, I added the following lines in my layout page.html(located in my folder _layouts)&lt;script type="text/javascript"  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"&gt;&lt;/script&gt;Of course you can choose a different file location in your jekyll layouts.A Couple of ExamplesHere’s a short list of examples. To know more about the details behind MathJax, you canalways checked the provided documentation available athttps://docs.mathjax.org/en/latest/I’m assuming you are familiar with LaTeX. However, you should know that MathJax does nothave the exactly same behavior as LaTeX. By default, the tex2jax preprocessor defines theLaTeX math delimiters, which are \\(...\\) for in-line math, and \\[...\\] fordisplayed equations. It also defines the TeX delimiters $$...$$ for displayedequations, but it does not define $...$ as in-line math delimiters. Fortunately,you can change these predefined specifications if you want to do so.Let’s try a first example. Here’s a dummy equation:How do you write such expression? Very simple: using double dollar signs$$a^2 + b^2 = c^2$$To display inline math use \\( ... \\) like this \\( sin(x^2) \\) which getsrendered as \( sin(x^2) \)Here’s another example using type \mathsf$$ \mathsf{Data = PCs} \times \mathsf{Loadings} $$which gets displayed asOr even better:\\[ \mathbf{X} = \mathbf{Z} \mathbf{P^\mathsf{T}} \\]is displayed as\[ \mathbf{X} = \mathbf{Z} \mathbf{P^\mathsf{T}} \]If you want to use subscripts like this \( \mathbf{X}_{n,p} \) you need to scape theunderscores with a backslash like so \mathbf{X}\_{n,p}:$$ \mathbf{X}\_{n,p} = \mathbf{A}\_{n,k} \mathbf{B}\_{k,p} $$will be displayed as\[ \mathbf{X}_{n,p} = \mathbf{A}_{n,k} \mathbf{B}_{k,p} \]]]></content>
      <categories>
        
          <category> test </category>
        
      </categories>
      <tags>
        
          <tag> test </tag>
        
          <tag> jekyll </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
